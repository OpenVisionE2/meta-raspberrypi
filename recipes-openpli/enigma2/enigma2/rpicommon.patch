diff -Naur enigma2-pli/lib/base/condVar.cpp enigma2-rpicommon/lib/base/condVar.cpp
--- enigma2-pli/lib/base/condVar.cpp	1970-01-01 00:00:00.000000000 +0000
+++ enigma2-rpicommon/lib/base/condVar.cpp	2018-10-23 23:44:47.206213450 +0000
@@ -0,0 +1,186 @@
+/*
+ * condVar.cpp: A simple thread base class
+ *
+ * Code from vdr/thread.c
+ * $Id: thread.c 3.2 2013/12/29 15:26:33 kls Exp $
+ * See the main source file 'vdr.c' for copyright information and
+ * how to reach the author.
+ *
+ */
+
+#include <lib/base/condVar.h>
+
+#if !defined(max)
+#define max(a, b)       ((a) > (b) ? (a) : (b))
+#endif
+
+static bool GetAbsTime(struct timespec *Abstime, int MillisecondsFromNow)
+{
+  struct timeval now;
+  if (gettimeofday(&now, NULL) == 0) {           // get current time
+     now.tv_sec  += MillisecondsFromNow / 1000;  // add full seconds
+     now.tv_usec += (MillisecondsFromNow % 1000) * 1000;  // add microseconds
+     if (now.tv_usec >= 1000000) {               // take care of an overflow
+        now.tv_sec++;
+        now.tv_usec -= 1000000;
+        }
+     Abstime->tv_sec = now.tv_sec;          // seconds
+     Abstime->tv_nsec = now.tv_usec * 1000; // nano seconds
+     return true;
+     }
+  return false;
+}
+
+// --- cMutex ----------------------------------------------------------------
+
+cMutex::cMutex(void)
+{
+  locked = 0;
+  pthread_mutexattr_t attr;
+  pthread_mutexattr_init(&attr);
+  pthread_mutexattr_settype(&attr, PTHREAD_MUTEX_ERRORCHECK_NP);
+  pthread_mutex_init(&mutex, &attr);
+}
+
+cMutex::~cMutex()
+{
+  pthread_mutex_destroy(&mutex);
+}
+
+void cMutex::Lock(void)
+{
+  pthread_mutex_lock(&mutex);
+  locked++;
+}
+
+void cMutex::Unlock(void)
+{
+ if (!--locked)
+    pthread_mutex_unlock(&mutex);
+}
+
+// --- cCondVar --------------------------------------------------------------
+
+cCondVar::cCondVar(void)
+{
+  pthread_cond_init(&cond, 0);
+}
+
+cCondVar::~cCondVar()
+{
+  pthread_cond_broadcast(&cond); // wake up any sleepers
+  pthread_cond_destroy(&cond);
+}
+
+void cCondVar::Wait(cMutex &Mutex)
+{
+  if (Mutex.locked) {
+     int locked = Mutex.locked;
+     Mutex.locked = 0; // have to clear the locked count here, as pthread_cond_wait
+                       // does an implicit unlock of the mutex
+     pthread_cond_wait(&cond, &Mutex.mutex);
+     Mutex.locked = locked;
+     }
+}
+
+bool cCondVar::TimedWait(cMutex &Mutex, int TimeoutMs)
+{
+  bool r = true; // true = condition signaled, false = timeout
+
+  if (Mutex.locked) {
+     struct timespec abstime;
+     if (GetAbsTime(&abstime, TimeoutMs)) {
+        int locked = Mutex.locked;
+        Mutex.locked = 0; // have to clear the locked count here, as pthread_cond_timedwait
+                          // does an implicit unlock of the mutex.
+        if (pthread_cond_timedwait(&cond, &Mutex.mutex, &abstime) == ETIMEDOUT)
+           r = false;
+        Mutex.locked = locked;
+        }
+     }
+  return r;
+}
+
+void cCondVar::Broadcast(void)
+{
+  pthread_cond_broadcast(&cond);
+}
+
+// --- cCondWait -------------------------------------------------------------
+
+cCondWait::cCondWait(void)
+{
+  signaled = false;
+  pthread_mutex_init(&mutex, NULL);
+  pthread_cond_init(&cond, NULL);
+}
+
+cCondWait::~cCondWait()
+{
+  pthread_cond_broadcast(&cond); // wake up any sleepers
+  pthread_cond_destroy(&cond);
+  pthread_mutex_destroy(&mutex);
+}
+
+void cCondWait::SleepMs(int TimeoutMs)
+{
+  cCondWait w;
+  w.Wait(max(TimeoutMs, 3)); // making sure the time is >2ms to avoid a possible busy wait
+}
+
+bool cCondWait::Wait(int TimeoutMs)
+{
+  pthread_mutex_lock(&mutex);
+  if (!signaled) {
+     if (TimeoutMs) {
+        struct timespec abstime;
+        if (GetAbsTime(&abstime, TimeoutMs)) {
+           while (!signaled) {
+                 if (pthread_cond_timedwait(&cond, &mutex, &abstime) == ETIMEDOUT)
+                    break;
+                 }
+           }
+        }
+     else
+        pthread_cond_wait(&cond, &mutex);
+     }
+  bool r = signaled;
+  signaled = false;
+  pthread_mutex_unlock(&mutex);
+  return r;
+}
+
+void cCondWait::Signal(void)
+{
+  pthread_mutex_lock(&mutex);
+  signaled = true;
+  pthread_cond_broadcast(&cond);
+  pthread_mutex_unlock(&mutex);
+}
+
+// --- cMutexLock ------------------------------------------------------------
+
+cMutexLock::cMutexLock(cMutex *Mutex)
+{
+  mutex = NULL;
+  locked = false;
+  Lock(Mutex);
+}
+
+cMutexLock::~cMutexLock()
+{
+  if (mutex && locked)
+     mutex->Unlock();
+}
+
+bool cMutexLock::Lock(cMutex *Mutex)
+{
+  if (Mutex && !mutex) {
+     mutex = Mutex;
+     Mutex->Lock();
+     locked = true;
+     return true;
+     }
+  return false;
+}
+
diff -Naur enigma2-pli/lib/base/condVar.h enigma2-rpicommon/lib/base/condVar.h
--- enigma2-pli/lib/base/condVar.h	1970-01-01 00:00:00.000000000 +0000
+++ enigma2-rpicommon/lib/base/condVar.h	2018-10-23 23:44:47.296215693 +0000
@@ -0,0 +1,214 @@
+/*
+ * condVar.h: A simple thread base class
+ *
+ * Code from vdr/thread.h
+ * $Id: thread.h 3.2 2015/01/14 11:39:55 kls Exp $
+ * See the main source file 'vdr.c' for copyright information and
+ * how to reach the author.
+ *
+ */
+
+#ifndef __THREAD_H
+#define __THREAD_H
+
+#include <errno.h>
+#include <pthread.h>
+#include <stdio.h>
+#include <sys/types.h>
+#include <sys/time.h>
+
+class cCondWait {
+private:
+  pthread_mutex_t mutex;
+  pthread_cond_t cond;
+  bool signaled;
+public:
+  cCondWait(void);
+  ~cCondWait();
+  static void SleepMs(int TimeoutMs);
+       ///< Creates a cCondWait object and uses it to sleep for TimeoutMs
+       ///< milliseconds, immediately giving up the calling thread's time
+       ///< slice and thus avoiding a "busy wait".
+       ///< In order to avoid a possible busy wait, TimeoutMs will be automatically
+       ///< limited to values >2.
+  bool Wait(int TimeoutMs = 0);
+       ///< Waits at most TimeoutMs milliseconds for a call to Signal(), or
+       ///< forever if TimeoutMs is 0.
+       ///< Returns true if Signal() has been called, false it the given
+       ///< timeout has expired.
+  void Signal(void);
+       ///< Signals a caller of Wait() that the condition it is waiting for is met.
+  };
+
+class cMutex;
+
+class cCondVar {
+private:
+  pthread_cond_t cond;
+public:
+  cCondVar(void);
+  ~cCondVar();
+  void Wait(cMutex &Mutex);
+  bool TimedWait(cMutex &Mutex, int TimeoutMs);
+  void Broadcast(void);
+  };
+
+class cRwLock {
+private:
+  pthread_rwlock_t rwlock;
+public:
+  cRwLock(bool PreferWriter = false);
+  ~cRwLock();
+  bool Lock(bool Write, int TimeoutMs = 0);
+  void Unlock(void);
+  };
+
+class cMutex {
+  friend class cCondVar;
+private:
+  pthread_mutex_t mutex;
+  int locked;
+public:
+  cMutex(void);
+  ~cMutex();
+  void Lock(void);
+  void Unlock(void);
+  };
+
+typedef pid_t tThreadId;
+
+class cThread {
+  friend class cThreadLock;
+private:
+  bool active;
+  bool running;
+  pthread_t childTid;
+  tThreadId childThreadId;
+  cMutex mutex;
+  char *description;
+  bool lowPriority;
+  static tThreadId mainThreadId;
+  static void *StartThread(cThread *Thread);
+protected:
+  void SetPriority(int Priority);
+  void SetIOPriority(int Priority);
+  void Lock(void) { mutex.Lock(); }
+  void Unlock(void) { mutex.Unlock(); }
+  virtual void Action(void) = 0;
+       ///< A derived cThread class must implement the code it wants to
+       ///< execute as a separate thread in this function. If this is
+       ///< a loop, it must check Running() repeatedly to see whether
+       ///< it's time to stop.
+  bool Running(void) { return running; }
+       ///< Returns false if a derived cThread object shall leave its Action()
+       ///< function.
+  void Cancel(int WaitSeconds = 0);
+       ///< Cancels the thread by first setting 'running' to false, so that
+       ///< the Action() loop can finish in an orderly fashion and then waiting
+       ///< up to WaitSeconds seconds for the thread to actually end. If the
+       ///< thread doesn't end by itself, it is killed.
+       ///< If WaitSeconds is -1, only 'running' is set to false and Cancel()
+       ///< returns immediately, without killing the thread.
+public:
+  cThread(const char *Description = NULL, bool LowPriority = false);
+       ///< Creates a new thread.
+       ///< If Description is present, a log file entry will be made when
+       ///< the thread starts and stops (see SetDescription()).
+       ///< The Start() function must be called to actually start the thread.
+       ///< LowPriority can be set to true to make this thread run at a lower
+       ///< priority.
+  virtual ~cThread();
+  void SetDescription(const char *Description, ...) __attribute__ ((format (printf, 2, 3)));
+       ///< Sets the description of this thread, which will be used when logging
+       ///< starting or stopping of the thread. Make sure any important information
+       ///< is within the first 15 characters of Description, because only these
+       ///< may be displayed in thread listings (like 'htop', for instance).
+  bool Start(void);
+       ///< Actually starts the thread.
+       ///< If the thread is already running, nothing happens.
+  bool Active(void);
+       ///< Checks whether the thread is still alive.
+  static tThreadId ThreadId(void);
+  static tThreadId IsMainThread(void) { return ThreadId() == mainThreadId; }
+  static void SetMainThreadId(void);
+  };
+
+// cMutexLock can be used to easily set a lock on mutex and make absolutely
+// sure that it will be unlocked when the block will be left. Several locks can
+// be stacked, so a function that makes many calls to another function which uses
+// cMutexLock may itself use a cMutexLock to make one longer lock instead of many
+// short ones.
+
+class cMutexLock {
+private:
+  cMutex *mutex;
+  bool locked;
+public:
+  cMutexLock(cMutex *Mutex = NULL);
+  ~cMutexLock();
+  bool Lock(cMutex *Mutex);
+  };
+
+// cThreadLock can be used to easily set a lock in a thread and make absolutely
+// sure that it will be unlocked when the block will be left. Several locks can
+// be stacked, so a function that makes many calls to another function which uses
+// cThreadLock may itself use a cThreadLock to make one longer lock instead of many
+// short ones.
+
+class cThreadLock {
+private:
+  cThread *thread;
+  bool locked;
+public:
+  cThreadLock(cThread *Thread = NULL);
+  ~cThreadLock();
+  bool Lock(cThread *Thread);
+  };
+
+#define LOCK_THREAD cThreadLock ThreadLock(this)
+
+class cIoThrottle {
+private:
+  static cMutex mutex;
+  static int count;
+  bool active;
+public:
+  cIoThrottle(void);
+  ~cIoThrottle();
+  void Activate(void);
+       ///< Activates the global I/O throttling mechanism.
+       ///< This function may be called any number of times, but only
+       ///< the first call after an inactive state will have an effect.
+  void Release(void);
+       ///< Releases the global I/O throttling mechanism.
+       ///< This function may be called any number of times, but only
+       ///< the first call after an active state will have an effect.
+  bool Active(void) { return active; }
+       ///< Returns true if this I/O throttling object is currently active.
+  static bool Engaged(void);
+       ///< Returns true if any I/O throttling object is currently active.
+  };
+
+// cPipe implements a pipe that closes all unnecessary file descriptors in
+// the child process.
+
+class cPipe {
+private:
+  pid_t pid;
+  FILE *f;
+public:
+  cPipe(void);
+  ~cPipe();
+  operator FILE* () { return f; }
+  bool Open(const char *Command, const char *Mode);
+  int Close(void);
+  };
+
+// SystemExec() implements a 'system()' call that closes all unnecessary file
+// descriptors in the child process.
+// With Detached=true, calls command in background and in a separate session,
+// with stdin connected to /dev/null.
+
+int SystemExec(const char *Command, bool Detached = false);
+
+#endif //__THREAD_H
diff -Naur enigma2-pli/lib/base/Makefile.inc enigma2-rpicommon/lib/base/Makefile.inc
--- enigma2-pli/lib/base/Makefile.inc	2018-10-23 22:20:52.485576058 +0000
+++ enigma2-rpicommon/lib/base/Makefile.inc	2018-10-24 22:42:41.105138964 +0000
@@ -4,6 +4,7 @@
 	base/buffer.cpp \
 	base/cachedtssource.cpp \
 	base/cfile.cpp \
+	base/condVar.cpp \
 	base/connection.cpp \
 	base/console.cpp \
 	base/e2avahi.cpp \
@@ -21,6 +22,8 @@
 	base/rawfile.cpp \
 	base/smartptr.cpp \
 	base/thread.cpp \
+	base/tools.cpp \
+	base/tsRingbuffer.cpp \
 	base/httpsstream.cpp \
 	base/httpstream.cpp \
 	base/wrappers.cpp
@@ -33,6 +36,7 @@
 	base/buffer.h \
 	base/cachedtssource.h \
 	base/cfile.h \
+	base/condVar.h \
 	base/console.h \
 	base/e2avahi.h \
 	base/ebase.h \
@@ -55,6 +59,8 @@
 	base/ringbuffer.h \
 	base/smartptr.h \
 	base/thread.h \
+	base/tools.h \
+	base/tsRingbuffer.h \
 	base/httpsstream.h \
 	base/httpstream.h \
 	base/wrappers.h
diff -Naur enigma2-pli/lib/base/rawfile.cpp enigma2-rpicommon/lib/base/rawfile.cpp
--- enigma2-pli/lib/base/rawfile.cpp	2018-10-23 22:20:52.655580971 +0000
+++ enigma2-rpicommon/lib/base/rawfile.cpp	2018-10-28 14:35:54.419491530 +0000
@@ -37,6 +37,13 @@
 	return m_fd;
 }
 
+void eRawFile::setfd(int fd)
+{
+	close();
+	m_nrfiles = 1;
+	m_fd = fd;
+}
+
 off_t eRawFile::lseek_internal(off_t offset)
 {
 //	eDebug("[eRawFile] lseek: %lld, %d", offset, whence);
@@ -175,3 +182,124 @@
 {
 	return m_last_offset;
 }
+
+#define KILOBYTE(n) ((n) * 1024)
+#define MEGABYTE(n) ((n) * 1024LL * 1024LL)
+#define AUDIO_STREAM_S   0xC0
+#define AUDIO_STREAM_E   0xDF
+#define VIDEO_STREAM_S   0xE0
+#define VIDEO_STREAM_E   0xEF
+
+eDecryptRawFile::eDecryptRawFile(int packetsize)
+ : eRawFile(packetsize)
+{
+	ringBuffer = new cRingBufferLinear(KILOBYTE(8192),TS_SIZE,true,"IN-TS");
+	ringBuffer->SetTimeouts(100,100);
+	bs_size = dvbcsa_bs_batch_size();
+	delivered=false;
+	lastPacketsCount = 0;
+	stream_correct = false;
+}
+
+eDecryptRawFile::~eDecryptRawFile()
+{
+	delete ringBuffer;
+}
+
+void eDecryptRawFile::setDemux(ePtr<eDVBDemux> _demux) {
+	demux = _demux;
+}
+
+uint8_t* eDecryptRawFile::getPackets(int &packetsCount) {
+	int Count=0;
+	if(delivered) {
+		ringBuffer->Del(lastPacketsCount*TS_SIZE);
+		delivered=false;
+	}
+	packetsCount = 0;
+
+	if (ringBuffer->Available()<bs_size*TS_SIZE)
+		return NULL;
+
+	uint8_t* p=ringBuffer->Get(Count);
+	if (Count>KILOBYTE(16))
+		Count = KILOBYTE(16);
+
+	if(p && Count>=TS_SIZE) {
+		if(*p!=TS_SYNC_BYTE) {
+			for(int i=1; i<Count; i++)
+				if(p[i]==TS_SYNC_BYTE &&
+						(i+TS_SIZE==Count || (i+TS_SIZE>Count && p[i+TS_SIZE]==TS_SYNC_BYTE)) ) {
+					Count=i;
+					break;
+				}
+				ringBuffer->Del(Count);
+				eDebug("ERROR: skipped %d bytes to sync on TS packet", Count);
+				return NULL;
+		}
+		if(!demux->decrypt(p, Count, packetsCount)) {
+			cCondWait::SleepMs(20);
+			return NULL;
+		}
+		lastPacketsCount = packetsCount;
+		delivered=true;
+		return p;
+	}
+
+	return NULL;
+}
+
+ssize_t eDecryptRawFile::read(off_t offset, void *buf, size_t count)
+{
+	eSingleLocker l(m_lock);
+	int ret = 0;
+
+	while (ringBuffer->Available()<KILOBYTE(32)) {
+		ret = ringBuffer->Read(m_fd, KILOBYTE(16));
+		if (ret<0)
+			break;
+	}
+
+	int packetsCount = 0;
+
+	uint8_t *data = getPackets(packetsCount);
+
+	ret = -EBUSY;
+	if (data && packetsCount>0) {
+		if (!stream_correct) {
+			for (int i=0;i<packetsCount;i++) {
+				unsigned char* packet = data+i*TS_SIZE;
+				int adaptation_field_exist = (packet[3]&0x30)>>4;
+				unsigned char* wsk;
+				int len;
+
+				if (adaptation_field_exist==3) {
+					wsk = packet+5+packet[4];
+					len = 183-packet[4];
+				} else {
+					wsk = packet+4;
+					len = 184;
+				}
+
+				if (len>4 && wsk[0]==0 && wsk[1]==0 && wsk[2]==1
+						&& ((wsk[3]>=VIDEO_STREAM_S && wsk[3]<=VIDEO_STREAM_E)
+						|| (wsk[3]>=AUDIO_STREAM_S && wsk[3]<=AUDIO_STREAM_E)) ) {
+					stream_correct = true;
+					printf("-------------------- I have PES ---------------------- %02X\n", wsk[3]);
+					ret = (packetsCount-i)*TS_SIZE;
+					memcpy(buf, packet, (packetsCount-i)*TS_SIZE);
+/* When channel descramble, then start xineLib-playVideo()			---------> To recode for rpi with omx
+					cXineLib *xineLib = cXineLib::getInstance();
+					xineLib->setScrambled(false);
+					xineLib->playVideo();	*/
+					break;
+				}
+			}
+          	} else {
+			ret = packetsCount*TS_SIZE;
+			memcpy(buf, data, ret);
+		}
+	}
+
+	return ret;
+}
diff -Naur enigma2-pli/lib/base/rawfile.h enigma2-rpicommon/lib/base/rawfile.h
--- enigma2-pli/lib/base/rawfile.h	2018-10-23 22:20:52.655580971 +0000
+++ enigma2-rpicommon/lib/base/rawfile.h	2018-10-28 14:04:23.962389571 +0000
@@ -3,23 +3,29 @@
 
 #include <string>
 #include <lib/base/itssource.h>
+#include <lib/base/tsRingbuffer.h>
+#include <lib/dvb/edvbdemux.h>
 
 class eRawFile: public iTsSource
 {
 	DECLARE_REF(eRawFile);
-	eSingleLock m_lock;
+//	eSingleLock m_lock;
 public:
 	eRawFile(int packetsize = 188);
 	~eRawFile();
 	int open(const char *filename);
+	void setfd(int fd);
 
 	// iTsSource
 	ssize_t read(off_t offset, void *buf, size_t count);
 	off_t length();
 	off_t offset();
 	int valid();
-private:
+//private:
+protected:
+	eSingleLock m_lock;
 	int m_fd;
+private:
 	int m_nrfiles;
 	off_t m_splitsize;
 	off_t m_totallength;
@@ -36,4 +42,22 @@
 	int openFileUncached(int nr);
 };
 
+class eDecryptRawFile: public eRawFile
+{
+public:
+	eDecryptRawFile(int packetsize = 188);
+	~eDecryptRawFile();
+	void setDemux(ePtr<eDVBDemux> demux);
+	ssize_t read(off_t offset, void *buf, size_t count);
+private:
+	ePtr<eDVBDemux> demux;
+	cRingBufferLinear *ringBuffer;
+	int bs_size;
+	bool delivered;
+	int lastPacketsCount;
+	bool stream_correct;
+
+	uint8_t* getPackets(int &packetsCount);
+};
+
 #endif
diff -Naur enigma2-pli/lib/base/tsRingbuffer.cpp enigma2-rpicommon/lib/base/tsRingbuffer.cpp
--- enigma2-pli/lib/base/tsRingbuffer.cpp	1970-01-01 00:00:00.000000000 +0000
+++ enigma2-rpicommon/lib/base/tsRingbuffer.cpp	2018-10-25 22:24:17.698082820 +0000
@@ -0,0 +1,336 @@
+/*
+ * tsRingbuffer.cpp: A ring buffer
+ *
+ * See the main source file 'vdr.c' for copyright information and
+ * how to reach the author.
+ *
+ * Parts of this file were inspired by the 'ringbuffy.c' from the
+ * LinuxDVB driver (see linuxtv.org).
+ * code from:
+ * $Id: ringbuffer.c 3.0 2012/09/22 11:26:49 kls Exp $
+ *
+ */
+
+#include <lib/base/tsRingbuffer.h>
+#include <lib/base/eerror.h>
+#include <stdlib.h>
+#include <unistd.h>
+
+// --- cRingBuffer -----------------------------------------------------------
+
+#define OVERFLOWREPORTDELTA 5 // seconds between reports
+#define PERCENTAGEDELTA     10
+#define PERCENTAGETHRESHOLD 70
+
+cRingBuffer::cRingBuffer(int Size, bool Statistics)
+{
+	size = Size;
+	statistics = Statistics;
+	maxFill = 0;
+	lastPercent = 0;
+	putTimeout = getTimeout = 0;
+	lastOverflowReport = 0;
+	overflowCount = overflowBytes = 0;
+}
+
+cRingBuffer::~cRingBuffer()
+{
+	if (statistics)
+		eLog(3, "[cRingBuffer] buffer stats: %d (%d%%) used\n", maxFill, maxFill * 100 / (size - 1));
+}
+
+void cRingBuffer::UpdatePercentage(int Fill)
+{
+	if (Fill > maxFill)
+		maxFill = Fill;
+	int percent = Fill * 100 / (Size() - 1) / PERCENTAGEDELTA * PERCENTAGEDELTA; // clamp down to nearest quantum
+	if (percent != lastPercent) {
+
+	if (percent >= PERCENTAGETHRESHOLD && percent > lastPercent || percent < PERCENTAGETHRESHOLD && lastPercent >= PERCENTAGETHRESHOLD) {
+		eLog(3, "[cRingBuffer] buffer usage: %d%%\n", percent);
+		lastPercent = percent;
+    }
+  }
+}
+
+void cRingBuffer::WaitForPut(void)
+{
+	if (putTimeout)
+		readyForPut.Wait(putTimeout);
+}
+
+void cRingBuffer::WaitForGet(void)
+{
+	if (getTimeout)
+		readyForGet.Wait(getTimeout);
+}
+
+void cRingBuffer::EnablePut(void)
+{
+	if (putTimeout && Free() > Size() / 10)
+		readyForPut.Signal();
+}
+
+void cRingBuffer::EnableGet(void)
+{
+	if (getTimeout && Available() > Size() / 10)
+		readyForGet.Signal();
+}
+
+void cRingBuffer::SetTimeouts(int PutTimeout, int GetTimeout)
+{
+	putTimeout = PutTimeout;
+	getTimeout = GetTimeout;
+}
+
+void cRingBuffer::ReportOverflow(int Bytes)
+{
+	overflowCount++;
+	overflowBytes += Bytes;
+	if (time(NULL) - lastOverflowReport > OVERFLOWREPORTDELTA) {
+		eLog(1, "[cRingBuffer] ERROR: %d ring buffer overflow%s (%d bytes dropped)\n", overflowCount, overflowCount > 1 ? "s" : "", overflowBytes);
+		overflowCount = overflowBytes = 0;
+		lastOverflowReport = time(NULL);
+     }
+}
+
+// --- cRingBufferLinear -----------------------------------------------------
+
+#ifdef DEBUGRINGBUFFERS
+#define MAXRBLS 30
+#define DEBUGRBLWIDTH 45
+
+cRingBufferLinear *cRingBufferLinear::RBLS[MAXRBLS] = { NULL };
+
+void cRingBufferLinear::AddDebugRBL(cRingBufferLinear *RBL)
+{
+	for (int i = 0; i < MAXRBLS; i++) {
+		if (!RBLS[i]) {
+			RBLS[i] = RBL;
+			break;
+		}
+	}
+}
+
+void cRingBufferLinear::DelDebugRBL(cRingBufferLinear *RBL)
+{
+	for (int i = 0; i < MAXRBLS; i++) {
+		if (RBLS[i] == RBL) {
+			RBLS[i] = NULL;
+			break;
+		}
+	}
+}
+
+void cRingBufferLinear::PrintDebugRBL(void)
+{
+	bool printed = false;
+	for (int i = 0; i < MAXRBLS; i++) {
+		cRingBufferLinear *p = RBLS[i];
+		if (p) {
+			printed = true;
+			int lh = p->lastHead;
+			int lt = p->lastTail;
+			int h = lh * DEBUGRBLWIDTH / p->Size();
+			int t = lt * DEBUGRBLWIDTH / p->Size();
+			char buf[DEBUGRBLWIDTH + 10];
+			memset(buf, '-', DEBUGRBLWIDTH);
+			if (lt <= lh)
+				memset(buf + t, '*', max(h - t, 1));
+			else {
+				memset(buf, '*', h);
+				memset(buf + t, '*', DEBUGRBLWIDTH - t);
+			}
+		buf[t] = '<';
+		buf[h] = '>';
+		buf[DEBUGRBLWIDTH] = 0;
+		eDebug("[cRingBuffer] %2d %s %8d %8d %s\n", i, buf, p->lastPut, p->lastGet, p->description);
+		}
+	}
+	if (printed)
+		eDebug("[cRingBuffer] printed\n");
+  }
+#endif
+
+cRingBufferLinear::cRingBufferLinear(int Size, int Margin, bool Statistics, const char *Description)
+:cRingBuffer(Size, Statistics)
+{
+	description = Description ? strdup(Description) : NULL;
+	tail = head = margin = Margin;
+	gotten = 0;
+	buffer = NULL;
+	if (Size > 1) { // 'Size - 1' must not be 0!
+		if (Margin <= Size / 2) {
+			buffer = (uint8_t*)malloc(sizeof(uint8_t) * Size);
+		if (!buffer)
+			eLog(1, "[cRingBuffer] ERROR: can't allocate ring buffer (size=%d)\n", Size);
+		Clear();
+		}
+		else
+			eLog(1, "[cRingBuffer] ERROR: invalid margin for ring buffer (%d > %d)\n", Margin, Size / 2);
+	}
+	else
+		eLog(1, "[cRingBuffer] ERROR: invalid size for ring buffer (%d)\n", Size);
+#ifdef DEBUGRINGBUFFERS
+	lastHead = head;
+	lastTail = tail;
+	lastPut = lastGet = -1;
+	AddDebugRBL(this);
+#endif
+}
+
+cRingBufferLinear::~cRingBufferLinear()
+{
+#ifdef DEBUGRINGBUFFERS
+	DelDebugRBL(this);
+#endif
+	free(buffer);
+	free(description);
+}
+
+int cRingBufferLinear::DataReady(const uint8_t *Data, int Count)
+{
+	return Count >= margin ? Count : 0;
+}
+
+int cRingBufferLinear::Available(void)
+{
+	int diff = head - tail;
+	return (diff >= 0) ? diff : Size() + diff - margin;
+}
+
+void cRingBufferLinear::Clear(void)
+{
+	tail = head = margin;
+#ifdef DEBUGRINGBUFFERS
+	lastHead = head;
+	lastTail = tail;
+	lastPut = lastGet = -1;
+#endif
+	maxFill = 0;
+	EnablePut();
+}
+
+int cRingBufferLinear::Read(int FileHandle, int Max)
+{
+	int Tail = tail;
+	int diff = Tail - head;
+	int free = (diff > 0) ? diff - 1 : Size() - head;
+	if (Tail <= margin)
+		free--;
+	int Count = -1;
+	errno = EAGAIN;
+
+	if (free > 0) {
+		if (0 < Max && Max < free)
+		free = Max;
+		Count = read(FileHandle, buffer + head, free);
+		if (Count > 0) {
+			int Head = head + Count;
+			if (Head >= Size())
+				Head = margin;
+			head = Head;
+			if (statistics) {
+				int fill = head - Tail;
+				if (fill < 0)
+					fill = Size() + fill;
+				else if (fill >= Size())
+					fill = Size() - 1;
+				UpdatePercentage(fill);
+			}
+		}
+	}
+#ifdef DEBUGRINGBUFFERS
+	lastHead = head;
+	lastPut = Count;
+#endif
+	EnableGet();
+	if (free == 0)
+		WaitForPut();
+	return Count;
+}
+
+int cRingBufferLinear::Put(const uint8_t *Data, int Count)
+{
+	if (Count > 0) {
+		int Tail = tail;
+		int rest = Size() - head;
+		int diff = Tail - head;
+		int free = ((Tail < margin) ? rest : (diff > 0) ? diff : Size() + diff - margin) - 1;
+		if (statistics) {
+			int fill = Size() - free - 1 + Count;
+			if (fill >= Size())
+				fill = Size() - 1;
+			UpdatePercentage(fill);
+        }
+		if (free > 0) {
+			if (free < Count)
+				Count = free;
+			if (Count >= rest) {
+				memcpy(buffer + head, Data, rest);
+				if (Count - rest)
+					memcpy(buffer + margin, Data + rest, Count - rest);
+				head = margin + Count - rest;
+			}
+			else {
+				memcpy(buffer + head, Data, Count);
+				head += Count;
+			}
+		}
+		else
+			Count = 0;
+#ifdef DEBUGRINGBUFFERS
+	lastHead = head;
+	lastPut = Count;
+#endif
+	EnableGet();
+	if (Count == 0)
+		WaitForPut();
+	}
+	return Count;
+}
+
+uint8_t *cRingBufferLinear::Get(int &Count)
+{
+	int Head = head;
+	int rest = Size() - tail;
+	if (rest < margin && Head < tail) {
+		int t = margin - rest;
+		memcpy(buffer + t, buffer + tail, rest);
+		tail = t;
+		rest = Head - tail;
+	}
+	int diff = Head - tail;
+	int cont = (diff >= 0) ? diff : Size() + diff - margin;
+	if (cont > rest)
+		cont = rest;
+	uint8_t *p = buffer + tail;
+
+	if ((cont = DataReady(p, cont)) > 0) {
+		Count = gotten = cont;
+		return p;
+	}
+	WaitForGet();
+	return NULL;
+}
+
+void cRingBufferLinear::Del(int Count)
+{
+	if (Count > gotten) {
+		eLog(1, "[cRingBuffer] ERROR: invalid Count in cRingBufferLinear::Del: %d (limited to %d)\n", Count, gotten);
+		Count = gotten;
+	}
+	if (Count > 0) {
+		int Tail = tail;
+		Tail += Count;
+		gotten -= Count;
+		if (Tail >= Size())
+			Tail = margin;
+		tail = Tail;
+		EnablePut();
+	}
+#ifdef DEBUGRINGBUFFERS
+	lastTail = tail;
+	lastGet = Count;
+#endif
+}
diff -Naur enigma2-pli/lib/base/tsRingbuffer.h enigma2-rpicommon/lib/base/tsRingbuffer.h
--- enigma2-pli/lib/base/tsRingbuffer.h	1970-01-01 00:00:00.000000000 +0000
+++ enigma2-rpicommon/lib/base/tsRingbuffer.h	2018-10-25 22:27:36.253904941 +0000
@@ -0,0 +1,100 @@
+/*
+ * TSringbuffer.h: A ring buffer
+ *
+ * See the main source file 'vdr.c' for copyright information and
+ * how to reach the author.
+ * code from:
+ * $Id: ringbuffer.h 3.0 2013/02/16 15:20:37 kls Exp $
+ */
+ 
+#ifndef __tsringbuffer_h
+#define __tsringbuffer_h
+
+#include <lib/base/condVar.h>
+#include <lib/base/tools.h>
+
+class cRingBuffer {
+private:
+	cCondWait readyForPut, readyForGet;
+	int putTimeout;
+	int getTimeout;
+	int size;
+	time_t lastOverflowReport;
+	int overflowCount;
+	int overflowBytes;
+protected:
+	int maxFill;//XXX
+	int lastPercent;
+	bool statistics;//XXX
+	void UpdatePercentage(int Fill);
+	void WaitForPut(void);
+	void WaitForGet(void);
+	void EnablePut(void);
+	void EnableGet(void);
+	virtual void Clear(void) = 0;
+	virtual int Available(void) = 0;
+	virtual int Free(void) { return Size() - Available() - 1; }
+	int Size(void) { return size; }
+public:
+	cRingBuffer(int Size, bool Statistics = false);
+	virtual ~cRingBuffer();
+	void SetTimeouts(int PutTimeout, int GetTimeout);
+	void ReportOverflow(int Bytes);
+};
+
+class cRingBufferLinear : public cRingBuffer {
+//#define DEBUGRINGBUFFERS
+#ifdef DEBUGRINGBUFFERS
+private:
+	int lastHead, lastTail;
+	int lastPut, lastGet;
+	static cRingBufferLinear *RBLS[];
+	static void AddDebugRBL(cRingBufferLinear *RBL);
+	static void DelDebugRBL(cRingBufferLinear *RBL);
+public:
+  static void PrintDebugRBL(void);
+#endif
+private:
+	int margin, head, tail;
+	int gotten;
+	uint8_t *buffer;
+	char *description;
+protected:
+	virtual int DataReady(const uint8_t *Data, int Count);
+		///< By default a ring buffer has data ready as soon as there are at least
+		///< 'margin' bytes available. A derived class can reimplement this function
+		///< if it has other conditions that define when data is ready.
+		///< The return value is either 0 if there is not yet enough data available,
+		///< or the number of bytes from the beginning of Data that are "ready".
+public:
+	cRingBufferLinear(int Size, int Margin = 0, bool Statistics = false, const char *Description = NULL);
+		///< Creates a linear ring buffer.
+		///< The buffer will be able to hold at most Size-Margin-1 bytes of data, and will
+		///< be guaranteed to return at least Margin bytes in one consecutive block.
+		///< The optional Description is used for debugging only.
+	virtual ~cRingBufferLinear();
+	virtual int Available(void);
+	virtual int Free(void) { return Size() - Available() - 1 - margin; }
+	virtual void Clear(void);
+		///< Immediately clears the ring buffer.
+	int Read(int FileHandle, int Max = 0);
+		///< Reads at most Max bytes from FileHandle and stores them in the
+		///< ring buffer. If Max is 0, reads as many bytes as possible.
+		///< Only one actual read() call is done.
+		///< Returns the number of bytes actually read and stored, or
+		///< an error value from the actual read() call.
+	int Put(const uint8_t *Data, int Count);
+		///< Puts at most Count bytes of Data into the ring buffer.
+		///< \return Returns the number of bytes actually stored.
+	uint8_t *Get(int &Count);
+		///< Gets data from the ring buffer.
+		///< The data will remain in the buffer until a call to Del() deletes it.
+		///< \return Returns a pointer to the data, and stores the number of bytes
+		///< actually available in Count. If the returned pointer is NULL, Count has no meaning.
+	void Del(int Count);
+		///< Deletes at most Count bytes from the ring buffer.
+		///< Count must be less or equal to the number that was returned by a previous
+		///< call to Get().
+};
+
+#endif
