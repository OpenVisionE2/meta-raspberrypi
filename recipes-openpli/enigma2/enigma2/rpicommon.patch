diff -Naur enigma2-pli/lib/base/condVar.cpp enigma2-rpi/lib/base/condVar.cpp
--- enigma2-pli/lib/base/condVar.cpp	1970-01-01 00:00:00.000000000 +0000
+++ enigma2-rpi/lib/base/condVar.cpp	2018-10-23 23:44:47.206213450 +0000
@@ -0,0 +1,186 @@
+/*
+ * condVar.cpp: A simple thread base class
+ *
+ * Code from vdr/thread.c
+ * $Id: thread.c 3.2 2013/12/29 15:26:33 kls Exp $
+ * See the main source file 'vdr.c' for copyright information and
+ * how to reach the author.
+ *
+ */
+
+#include <lib/base/condVar.h>
+
+#if !defined(max)
+#define max(a, b)       ((a) > (b) ? (a) : (b))
+#endif
+
+static bool GetAbsTime(struct timespec *Abstime, int MillisecondsFromNow)
+{
+  struct timeval now;
+  if (gettimeofday(&now, NULL) == 0) {           // get current time
+     now.tv_sec  += MillisecondsFromNow / 1000;  // add full seconds
+     now.tv_usec += (MillisecondsFromNow % 1000) * 1000;  // add microseconds
+     if (now.tv_usec >= 1000000) {               // take care of an overflow
+        now.tv_sec++;
+        now.tv_usec -= 1000000;
+        }
+     Abstime->tv_sec = now.tv_sec;          // seconds
+     Abstime->tv_nsec = now.tv_usec * 1000; // nano seconds
+     return true;
+     }
+  return false;
+}
+
+// --- cMutex ----------------------------------------------------------------
+
+cMutex::cMutex(void)
+{
+  locked = 0;
+  pthread_mutexattr_t attr;
+  pthread_mutexattr_init(&attr);
+  pthread_mutexattr_settype(&attr, PTHREAD_MUTEX_ERRORCHECK_NP);
+  pthread_mutex_init(&mutex, &attr);
+}
+
+cMutex::~cMutex()
+{
+  pthread_mutex_destroy(&mutex);
+}
+
+void cMutex::Lock(void)
+{
+  pthread_mutex_lock(&mutex);
+  locked++;
+}
+
+void cMutex::Unlock(void)
+{
+ if (!--locked)
+    pthread_mutex_unlock(&mutex);
+}
+
+// --- cCondVar --------------------------------------------------------------
+
+cCondVar::cCondVar(void)
+{
+  pthread_cond_init(&cond, 0);
+}
+
+cCondVar::~cCondVar()
+{
+  pthread_cond_broadcast(&cond); // wake up any sleepers
+  pthread_cond_destroy(&cond);
+}
+
+void cCondVar::Wait(cMutex &Mutex)
+{
+  if (Mutex.locked) {
+     int locked = Mutex.locked;
+     Mutex.locked = 0; // have to clear the locked count here, as pthread_cond_wait
+                       // does an implicit unlock of the mutex
+     pthread_cond_wait(&cond, &Mutex.mutex);
+     Mutex.locked = locked;
+     }
+}
+
+bool cCondVar::TimedWait(cMutex &Mutex, int TimeoutMs)
+{
+  bool r = true; // true = condition signaled, false = timeout
+
+  if (Mutex.locked) {
+     struct timespec abstime;
+     if (GetAbsTime(&abstime, TimeoutMs)) {
+        int locked = Mutex.locked;
+        Mutex.locked = 0; // have to clear the locked count here, as pthread_cond_timedwait
+                          // does an implicit unlock of the mutex.
+        if (pthread_cond_timedwait(&cond, &Mutex.mutex, &abstime) == ETIMEDOUT)
+           r = false;
+        Mutex.locked = locked;
+        }
+     }
+  return r;
+}
+
+void cCondVar::Broadcast(void)
+{
+  pthread_cond_broadcast(&cond);
+}
+
+// --- cCondWait -------------------------------------------------------------
+
+cCondWait::cCondWait(void)
+{
+  signaled = false;
+  pthread_mutex_init(&mutex, NULL);
+  pthread_cond_init(&cond, NULL);
+}
+
+cCondWait::~cCondWait()
+{
+  pthread_cond_broadcast(&cond); // wake up any sleepers
+  pthread_cond_destroy(&cond);
+  pthread_mutex_destroy(&mutex);
+}
+
+void cCondWait::SleepMs(int TimeoutMs)
+{
+  cCondWait w;
+  w.Wait(max(TimeoutMs, 3)); // making sure the time is >2ms to avoid a possible busy wait
+}
+
+bool cCondWait::Wait(int TimeoutMs)
+{
+  pthread_mutex_lock(&mutex);
+  if (!signaled) {
+     if (TimeoutMs) {
+        struct timespec abstime;
+        if (GetAbsTime(&abstime, TimeoutMs)) {
+           while (!signaled) {
+                 if (pthread_cond_timedwait(&cond, &mutex, &abstime) == ETIMEDOUT)
+                    break;
+                 }
+           }
+        }
+     else
+        pthread_cond_wait(&cond, &mutex);
+     }
+  bool r = signaled;
+  signaled = false;
+  pthread_mutex_unlock(&mutex);
+  return r;
+}
+
+void cCondWait::Signal(void)
+{
+  pthread_mutex_lock(&mutex);
+  signaled = true;
+  pthread_cond_broadcast(&cond);
+  pthread_mutex_unlock(&mutex);
+}
+
+// --- cMutexLock ------------------------------------------------------------
+
+cMutexLock::cMutexLock(cMutex *Mutex)
+{
+  mutex = NULL;
+  locked = false;
+  Lock(Mutex);
+}
+
+cMutexLock::~cMutexLock()
+{
+  if (mutex && locked)
+     mutex->Unlock();
+}
+
+bool cMutexLock::Lock(cMutex *Mutex)
+{
+  if (Mutex && !mutex) {
+     mutex = Mutex;
+     Mutex->Lock();
+     locked = true;
+     return true;
+     }
+  return false;
+}
+
diff -Naur enigma2-pli/lib/base/condVar.h enigma2-rpi/lib/base/condVar.h
--- enigma2-pli/lib/base/condVar.h	1970-01-01 00:00:00.000000000 +0000
+++ enigma2-rpi/lib/base/condVar.h	2018-10-23 23:44:47.296215693 +0000
@@ -0,0 +1,214 @@
+/*
+ * condVar.h: A simple thread base class
+ *
+ * Code from vdr/thread.h
+ * $Id: thread.h 3.2 2015/01/14 11:39:55 kls Exp $
+ * See the main source file 'vdr.c' for copyright information and
+ * how to reach the author.
+ *
+ */
+
+#ifndef __THREAD_H
+#define __THREAD_H
+
+#include <errno.h>
+#include <pthread.h>
+#include <stdio.h>
+#include <sys/types.h>
+#include <sys/time.h>
+
+class cCondWait {
+private:
+  pthread_mutex_t mutex;
+  pthread_cond_t cond;
+  bool signaled;
+public:
+  cCondWait(void);
+  ~cCondWait();
+  static void SleepMs(int TimeoutMs);
+       ///< Creates a cCondWait object and uses it to sleep for TimeoutMs
+       ///< milliseconds, immediately giving up the calling thread's time
+       ///< slice and thus avoiding a "busy wait".
+       ///< In order to avoid a possible busy wait, TimeoutMs will be automatically
+       ///< limited to values >2.
+  bool Wait(int TimeoutMs = 0);
+       ///< Waits at most TimeoutMs milliseconds for a call to Signal(), or
+       ///< forever if TimeoutMs is 0.
+       ///< Returns true if Signal() has been called, false it the given
+       ///< timeout has expired.
+  void Signal(void);
+       ///< Signals a caller of Wait() that the condition it is waiting for is met.
+  };
+
+class cMutex;
+
+class cCondVar {
+private:
+  pthread_cond_t cond;
+public:
+  cCondVar(void);
+  ~cCondVar();
+  void Wait(cMutex &Mutex);
+  bool TimedWait(cMutex &Mutex, int TimeoutMs);
+  void Broadcast(void);
+  };
+
+class cRwLock {
+private:
+  pthread_rwlock_t rwlock;
+public:
+  cRwLock(bool PreferWriter = false);
+  ~cRwLock();
+  bool Lock(bool Write, int TimeoutMs = 0);
+  void Unlock(void);
+  };
+
+class cMutex {
+  friend class cCondVar;
+private:
+  pthread_mutex_t mutex;
+  int locked;
+public:
+  cMutex(void);
+  ~cMutex();
+  void Lock(void);
+  void Unlock(void);
+  };
+
+typedef pid_t tThreadId;
+
+class cThread {
+  friend class cThreadLock;
+private:
+  bool active;
+  bool running;
+  pthread_t childTid;
+  tThreadId childThreadId;
+  cMutex mutex;
+  char *description;
+  bool lowPriority;
+  static tThreadId mainThreadId;
+  static void *StartThread(cThread *Thread);
+protected:
+  void SetPriority(int Priority);
+  void SetIOPriority(int Priority);
+  void Lock(void) { mutex.Lock(); }
+  void Unlock(void) { mutex.Unlock(); }
+  virtual void Action(void) = 0;
+       ///< A derived cThread class must implement the code it wants to
+       ///< execute as a separate thread in this function. If this is
+       ///< a loop, it must check Running() repeatedly to see whether
+       ///< it's time to stop.
+  bool Running(void) { return running; }
+       ///< Returns false if a derived cThread object shall leave its Action()
+       ///< function.
+  void Cancel(int WaitSeconds = 0);
+       ///< Cancels the thread by first setting 'running' to false, so that
+       ///< the Action() loop can finish in an orderly fashion and then waiting
+       ///< up to WaitSeconds seconds for the thread to actually end. If the
+       ///< thread doesn't end by itself, it is killed.
+       ///< If WaitSeconds is -1, only 'running' is set to false and Cancel()
+       ///< returns immediately, without killing the thread.
+public:
+  cThread(const char *Description = NULL, bool LowPriority = false);
+       ///< Creates a new thread.
+       ///< If Description is present, a log file entry will be made when
+       ///< the thread starts and stops (see SetDescription()).
+       ///< The Start() function must be called to actually start the thread.
+       ///< LowPriority can be set to true to make this thread run at a lower
+       ///< priority.
+  virtual ~cThread();
+  void SetDescription(const char *Description, ...) __attribute__ ((format (printf, 2, 3)));
+       ///< Sets the description of this thread, which will be used when logging
+       ///< starting or stopping of the thread. Make sure any important information
+       ///< is within the first 15 characters of Description, because only these
+       ///< may be displayed in thread listings (like 'htop', for instance).
+  bool Start(void);
+       ///< Actually starts the thread.
+       ///< If the thread is already running, nothing happens.
+  bool Active(void);
+       ///< Checks whether the thread is still alive.
+  static tThreadId ThreadId(void);
+  static tThreadId IsMainThread(void) { return ThreadId() == mainThreadId; }
+  static void SetMainThreadId(void);
+  };
+
+// cMutexLock can be used to easily set a lock on mutex and make absolutely
+// sure that it will be unlocked when the block will be left. Several locks can
+// be stacked, so a function that makes many calls to another function which uses
+// cMutexLock may itself use a cMutexLock to make one longer lock instead of many
+// short ones.
+
+class cMutexLock {
+private:
+  cMutex *mutex;
+  bool locked;
+public:
+  cMutexLock(cMutex *Mutex = NULL);
+  ~cMutexLock();
+  bool Lock(cMutex *Mutex);
+  };
+
+// cThreadLock can be used to easily set a lock in a thread and make absolutely
+// sure that it will be unlocked when the block will be left. Several locks can
+// be stacked, so a function that makes many calls to another function which uses
+// cThreadLock may itself use a cThreadLock to make one longer lock instead of many
+// short ones.
+
+class cThreadLock {
+private:
+  cThread *thread;
+  bool locked;
+public:
+  cThreadLock(cThread *Thread = NULL);
+  ~cThreadLock();
+  bool Lock(cThread *Thread);
+  };
+
+#define LOCK_THREAD cThreadLock ThreadLock(this)
+
+class cIoThrottle {
+private:
+  static cMutex mutex;
+  static int count;
+  bool active;
+public:
+  cIoThrottle(void);
+  ~cIoThrottle();
+  void Activate(void);
+       ///< Activates the global I/O throttling mechanism.
+       ///< This function may be called any number of times, but only
+       ///< the first call after an inactive state will have an effect.
+  void Release(void);
+       ///< Releases the global I/O throttling mechanism.
+       ///< This function may be called any number of times, but only
+       ///< the first call after an active state will have an effect.
+  bool Active(void) { return active; }
+       ///< Returns true if this I/O throttling object is currently active.
+  static bool Engaged(void);
+       ///< Returns true if any I/O throttling object is currently active.
+  };
+
+// cPipe implements a pipe that closes all unnecessary file descriptors in
+// the child process.
+
+class cPipe {
+private:
+  pid_t pid;
+  FILE *f;
+public:
+  cPipe(void);
+  ~cPipe();
+  operator FILE* () { return f; }
+  bool Open(const char *Command, const char *Mode);
+  int Close(void);
+  };
+
+// SystemExec() implements a 'system()' call that closes all unnecessary file
+// descriptors in the child process.
+// With Detached=true, calls command in background and in a separate session,
+// with stdin connected to /dev/null.
+
+int SystemExec(const char *Command, bool Detached = false);
+
+#endif //__THREAD_H
diff -Naur enigma2-pli/lib/base/Makefile.inc enigma2-rpi/lib/base/Makefile.inc
--- enigma2-pli/lib/base/Makefile.inc	2018-10-23 22:20:52.485576058 +0000
+++ enigma2-rpi/lib/base/Makefile.inc	2018-10-23 23:45:12.476842418 +0000
@@ -4,6 +4,7 @@
 	base/buffer.cpp \
 	base/cachedtssource.cpp \
 	base/cfile.cpp \
+	base/condVar.cpp \
 	base/connection.cpp \
 	base/console.cpp \
 	base/e2avahi.cpp \
@@ -21,6 +22,7 @@
 	base/rawfile.cpp \
 	base/smartptr.cpp \
 	base/thread.cpp \
+	base/tools.cpp \
 	base/httpsstream.cpp \
 	base/httpstream.cpp \
 	base/wrappers.cpp
@@ -33,6 +35,7 @@
 	base/buffer.h \
 	base/cachedtssource.h \
 	base/cfile.h \
+	base/condVar.h \
 	base/console.h \
 	base/e2avahi.h \
 	base/ebase.h \
@@ -55,6 +58,7 @@
 	base/ringbuffer.h \
 	base/smartptr.h \
 	base/thread.h \
+	base/tools.h \
 	base/httpsstream.h \
 	base/httpstream.h \
 	base/wrappers.h
diff -Naur enigma2-pli/lib/base/tools.cpp enigma2-rpi/lib/base/tools.cpp
--- enigma2-pli/lib/base/tools.cpp	1970-01-01 00:00:00.000000000 +0000
+++ enigma2-rpi/lib/base/tools.cpp	2018-10-23 23:45:03.246612898 +0000
@@ -0,0 +1,110 @@
+/*
+ * rpihddevice - Enigma2 rpihddevice library for Raspberry Pi
+ * Copyright (C) 2014, 2015, 2016 Thomas Reufer
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#include <limits.h>
+#include <lib/base/tools.h>
+#include <algorithm>
+
+/*
+ * ffmpeg's implementation for rational numbers:
+ * https://github.com/FFmpeg/FFmpeg/blob/master/libavutil/rational.c
+ */
+
+cRational::cRational(double d) :
+	num(0), den(0)
+{
+	int exp;
+	frexp(d, &exp);					/*	call to	vdr/tools.h		*/
+
+	den = 1LL << (29 - std::max(exp - 1, 0));
+	num = floor(d * den + 0.5);		/*	call to	vdr/tools.h		*/
+
+	Reduce(INT_MAX);
+}
+
+bool cRational::Reduce(int max)
+{
+	cRational a0 = cRational(0, 1), a1 = cRational(1, 0);
+	int sign = (num < 0) ^ (den < 0);
+	if (int div = Gcd(abs(num), abs(den)))
+	{
+		num = abs(num) / div;
+		den = abs(den) / div;
+	}
+	if (num <= max && den <= max)
+	{
+		a1 = cRational(num, den);
+		den = 0;
+	}
+	while (den)
+	{
+		int x = num / den;
+		int nextDen = num - den * x;
+		cRational a2 = cRational(x * a1.num + a0.num, x * a1.den + a0.den);
+		if (a2.num > max || a2.den > max)
+		{
+			if (a1.num)
+				x = (max - a0.num) / a1.num;
+			if (a1.den)
+				x = std::min(x, (max - a0.den) / a1.den);
+			if (den * (2 * x * a1.den + a0.den) > num * a1.den)
+				a1 = cRational(x * a1.num + a0.num, x * a1.den + a0.den);
+			break;
+		}
+		a0 = a1;
+		a1 = a2;
+		num = den;
+		den = nextDen;
+	}
+	num = sign ? -a1.num : a1.num;
+	den = a1.den;
+	return den == 0;
+}
+
+/*
+ * Stein's binary GCD algorithm:
+ * https://en.wikipedia.org/wiki/Binary_GCD_algorithm
+ */
+
+int cRational::Gcd(int u, int v)
+{
+    if (u == v || v == 0)
+        return u;
+
+    if (u == 0)
+        return v;
+
+    // look for factors of 2
+    if (~u & 1) // u is even
+    {
+        if (v & 1) // v is odd
+            return Gcd(u >> 1, v);
+        else // both u and v are even
+            return Gcd(u >> 1, v >> 1) << 1;
+    }
+
+    if (~v & 1) // u is odd, v is even
+        return Gcd(u, v >> 1);
+
+    // reduce larger argument
+    if (u > v)
+        return Gcd((u - v) >> 1, v);
+
+    return Gcd((v - u) >> 1, u);
+}
diff -Naur enigma2-pli/lib/base/tools.h enigma2-rpi/lib/base/tools.h
--- enigma2-pli/lib/base/tools.h	1970-01-01 00:00:00.000000000 +0000
+++ enigma2-rpi/lib/base/tools.h	2018-10-23 23:45:03.256613147 +0000
@@ -0,0 +1,370 @@
+/*
+ * rpihddevice - Enigma2 rpihddevice library for Raspberry Pi
+ * Copyright (C) 2014, 2015, 2016 Thomas Reufer
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#ifndef TOOLS_H
+#define TOOLS_H
+
+#include <errno.h>
+#include <math.h>
+#include <poll.h>
+#include <stdarg.h>
+#include <stddef.h>
+#include <stdint.h>
+
+//	vdr/tools.h
+
+typedef unsigned char uchar;
+
+#define SECSINDAY  86400
+
+#define KILOBYTE(n) ((n) * 1024)
+#define MEGABYTE(n) ((n) * 1024LL * 1024LL)
+
+#define MALLOC(type, size)  (type *)malloc(sizeof(type) * (size))
+
+class cString {
+private:
+  char *s;
+public:
+  cString(const char *S = NULL, bool TakePointer = false);
+  cString(const char *S, const char *To); ///< Copies S up to To (exclusive). To must be a valid pointer into S. If To is NULL, everything is copied.
+  cString(const cString &String);
+  virtual ~cString();
+  operator const void * () const { return s; } // to catch cases where operator*() should be used
+  operator const char * () const { return s; } // for use in (const char *) context
+  const char * operator*() const { return s; } // for use in (const void *) context (printf() etc.)
+  cString &operator=(const cString &String);
+  cString &operator=(const char *String);
+  cString &Truncate(int Index); ///< Truncate the string at the given Index (if Index is < 0 it is counted from the end of the string).
+  cString &CompactChars(char c); ///< Compact any sequence of characters 'c' to a single character, and strip all of them from the beginning and end of this string.
+  static cString sprintf(const char *fmt, ...) __attribute__ ((format (printf, 1, 2)));
+  static cString vsprintf(const char *fmt, va_list &ap);
+  };
+
+uchar *RgbToJpeg(uchar *Mem, int Width, int Height, int &Size, int Quality = 100);
+    ///< Converts the given Memory to a JPEG image and returns a pointer
+    ///< to the resulting image. Mem must point to a data block of exactly
+    ///< (Width * Height) triplets of RGB image data bytes. Upon return, Size
+    ///< will hold the number of bytes of the resulting JPEG data.
+    ///< Quality can be in the range 0..100 and controls the quality of the
+    ///< resulting image, where 100 is "best". The caller takes ownership of
+    ///< the result and has to delete it once it is no longer needed.
+    ///< The result may be NULL in case of an error.
+
+class cTimeMs {
+private:
+  uint64_t begin;
+public:
+  cTimeMs(int Ms = 0);
+      ///< Creates a timer with ms resolution and an initial timeout of Ms.
+      ///< If Ms is negative the timer is not initialized with the current
+      ///< time.
+  static uint64_t Now(void);
+  void Set(int Ms = 0);
+  bool TimedOut(void) const;
+  uint64_t Elapsed(void) const;
+  };
+
+class cPoller {
+private:
+  enum { MaxPollFiles = 16 };
+  pollfd pfd[MaxPollFiles];
+  int numFileHandles;
+public:
+  cPoller(int FileHandle = -1, bool Out = false);
+  bool Add(int FileHandle, bool Out);
+  bool Poll(int TimeoutMs = 0);
+  };  
+
+//	vdr/remux.h
+
+#define MAX33BIT  0x00000001FFFFFFFFLL // max. possible value with 33 bit
+
+inline bool PesLongEnough(int Length)
+{
+  return Length >= 6;
+}
+
+inline bool PesHasLength(const uchar *p)
+{
+  return p[4] | p[5];
+}
+
+inline int PesLength(const uchar *p)
+{
+  return 6 + p[4] * 256 + p[5];
+}
+
+inline int PesPayloadOffset(const uchar *p)
+{
+  return 9 + p[8];
+}
+
+inline bool PesHasPts(const uchar *p)
+{
+  return (p[7] & 0x80) && p[8] >= 5;
+}
+
+inline int64_t PesGetPts(const uchar *p)
+{
+  return ((((int64_t)p[ 9]) & 0x0E) << 29) |
+         (( (int64_t)p[10])         << 22) |
+         ((((int64_t)p[11]) & 0xFE) << 14) |
+         (( (int64_t)p[12])         <<  7) |
+         ((((int64_t)p[13]) & 0xFE) >>  1);
+}
+
+int64_t PtsDiff(int64_t Pts1, int64_t Pts2);
+       ///< Returns the difference between two PTS values. The result of Pts2 - Pts1
+       ///< is the actual number of 90kHz time ticks that pass from Pts1 to Pts2,
+       ///< properly taking into account the 33bit wrap around. If Pts2 is "before"
+       ///< Pts1, the result is negative.
+
+//	vdr/device.h
+
+// Note that VDR itself always uses pmAudioVideo when replaying a recording!
+enum ePlayMode { pmNone,           // audio/video from decoder
+                 pmAudioVideo,     // audio/video from player
+                 pmAudioOnly,      // audio only from player, video from decoder
+                 pmAudioOnlyBlack, // audio only from player, no video (black screen)
+                 pmVideoOnly,      // video only from player, audio from decoder
+                 pmExtern_THIS_SHOULD_BE_AVOIDED
+                 // external player (e.g. MPlayer), release the device
+                 // WARNING: USE THIS MODE ONLY AS A LAST RESORT, IF YOU
+                 // ABSOLUTELY, POSITIVELY CAN'T IMPLEMENT YOUR PLAYER
+                 // THE WAY IT IS SUPPOSED TO WORK. FORCING THE DEVICE
+                 // TO RELEASE ITS FILES HANDLES (OR WHATEVER RESOURCES
+                 // IT MAY USE) TO ALLOW AN EXTERNAL PLAYER TO ACCESS
+                 // THEM MEANS THAT SUCH A PLAYER WILL NEED TO HAVE
+                 // DETAILED KNOWLEDGE ABOUT THE INTERNALS OF THE DEVICE
+                 // IN USE. AS A CONSEQUENCE, YOUR PLAYER MAY NOT WORK
+                 // IF A PARTICULAR VDR INSTALLATION USES A DEVICE NOT
+                 // KNOWN TO YOUR PLAYER.
+               };
+			   
+//	------------------------------------------------------------------------------------------------
+
+class cVideoResolution
+{
+public:
+
+	enum eResolution {
+		eDontChange = 0,
+		eFollowVideo,
+		e480,
+		e480w,
+		e576,
+		e576w,
+		e720,
+		e1080
+	};
+
+	static const char* Str(eResolution resolution) {
+		return	(resolution == eDontChange)  ? "don't change" :
+				(resolution == eFollowVideo) ? "follow video" :
+				(resolution == e480)         ? "480"          :
+				(resolution == e480w)        ? "480w"         :
+				(resolution == e576)         ? "576"          :
+				(resolution == e576w)        ? "576w"         :
+				(resolution == e720)         ? "720"          :
+				(resolution == e1080)        ? "1080"         :	"unknown";
+	}
+};
+
+class cVideoFrameRate
+{
+public:
+
+	enum eFrameRate {
+		eDontChange = 0,
+		eFollowVideo,
+		e24p,
+		e25p,
+		e30p,
+		e50i,
+		e50p,
+		e60i,
+		e60p
+	};
+
+	static const char* Str(eFrameRate frameRate) {
+		return	(frameRate == eDontChange)  ? "don't change" :
+				(frameRate == eFollowVideo) ? "follow video" :
+				(frameRate == e24p)         ? "p24"          :
+				(frameRate == e25p)         ? "p25"          :
+				(frameRate == e30p)         ? "p30"          :
+				(frameRate == e50i)         ? "i50"          :
+				(frameRate == e50p)         ? "p50"          :
+				(frameRate == e60i)         ? "i60"          :
+				(frameRate == e60p)         ? "p60"          : "unknown";
+	}
+};
+
+class cVideoFraming
+{
+public:
+
+	enum eFraming {
+		eFrame,
+		eCut,
+		eStretch
+	};
+
+	static const char* Str(eFraming framing) {
+		return  (framing == eFrame)   ? "frame"   :
+				(framing == eCut)     ? "cut"     :
+				(framing == eStretch) ? "stretch" : "unknown";
+	}
+};
+
+class cAudioCodec
+{
+public:
+
+	enum eCodec {
+		ePCM,
+		eMPG,
+		eAC3,
+		eEAC3,
+		eAAC,
+		eAAC_LATM,
+		eDTS,
+		eNumCodecs,
+		eInvalid
+	};
+
+	static const char* Str(eCodec codec) {
+		return  (codec == ePCM)      ? "PCM"      :
+				(codec == eMPG)      ? "MPEG"     :
+				(codec == eAC3)      ? "AC3"      :
+				(codec == eEAC3)     ? "E-AC3"    :
+				(codec == eAAC)      ? "AAC"      :
+				(codec == eAAC_LATM) ? "AAC-LATM" :
+				(codec == eDTS)      ? "DTS"      : "unknown";
+	}
+};
+
+class cAudioFormat
+{
+public:
+
+	enum eFormat {
+		ePassThrough,
+		eMultiChannelPCM,
+		eStereoPCM
+	};
+
+	static const char* Str(eFormat format) {
+		return  (format == ePassThrough)     ? "pass through"      :
+				(format == eMultiChannelPCM) ? "multi channel PCM" :
+				(format == eStereoPCM)       ? "stereo PCM"        : "unknown";
+	}
+};
+
+class cVideoCodec
+{
+public:
+
+	enum eCodec {
+		eMPEG2,
+		eH264,
+		eNumCodecs,
+		eInvalid
+	};
+
+	static const char* Str(eCodec codec) {
+		return  (codec == eMPEG2) ? "MPEG2" :
+				(codec == eH264)  ? "H264"  : "unknown";
+	}
+};
+
+class cRpiAudioPort
+{
+public:
+
+	enum ePort {
+		eLocal,
+		eHDMI
+	};
+
+	static const char* Str(ePort port) {
+		return 	(port == eLocal) ? "local" :
+				(port == eHDMI)  ? "HDMI"  : "unknown";
+	}
+};
+
+class cScanMode
+{
+public:
+
+	enum eMode {
+		eProgressive,
+		eTopFieldFirst,
+		eBottomFieldFirst
+	};
+
+	static const char* Str(eMode mode) {
+		return 	(mode == eProgressive)      ? "progressive"      :
+				(mode == eTopFieldFirst)    ? "interlaced (tff)" :
+				(mode == eBottomFieldFirst) ? "interlaced (bff)" : "unknown";
+	}
+
+	static const bool Interlaced(eMode mode) {
+		return mode != eProgressive;
+	}
+};
+
+class cVideoFrameFormat
+{
+public:
+
+	cVideoFrameFormat() : width(0), height(0), frameRate(0),
+		scanMode(cScanMode::eProgressive), pixelWidth(0), pixelHeight(0) { };
+
+	int width;
+	int height;
+	int frameRate;
+	cScanMode::eMode scanMode;
+	int pixelWidth;
+	int pixelHeight;
+
+	bool Interlaced(void) const {
+		return cScanMode::Interlaced(scanMode);
+	}
+};
+
+class cRational
+{
+public:
+
+	cRational(double d);
+	cRational(int _num, int _den) : num(_num), den(_den) { }
+
+	bool Reduce(int max);
+
+	int num;
+	int den;
+
+private:
+
+	cRational();
+	static int Gcd(int u, int v);
+};
+
+#endif
