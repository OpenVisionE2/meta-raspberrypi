diff -Naur enigma2-PLi/lib/dvb/demux.cpp enigma2-PersianPrince/lib/dvb/demux.cpp
--- enigma2-PLi/lib/dvb/demux.cpp	2018-10-26 16:05:52.000000000 +0330
+++ enigma2-PersianPrince/lib/dvb/demux.cpp	2018-10-27 12:11:44.261287798 +0330
@@ -70,6 +70,9 @@
 	m_pvr_fd(-1),
 #endif
 	m_dvr_busy(0),
+/** {
+	decsa = new cDeCSA(adapter, demux); // Check this for RPi devices please
+} **/
 	m_dvr_id(-1),
 	m_dvr_source_offset(DMX_SOURCE_DVR0)
 {
@@ -80,6 +83,7 @@
 
 eDVBDemux::~eDVBDemux()
 {
+	delete decsa;
 }
 
 int eDVBDemux::openDemux(void)
@@ -209,6 +213,20 @@
 	return 0;
 }
 
+RESULT eDVBDemux::setCaDescr(ca_descr_t *ca_descr, bool initial)
+{
+	return decsa->SetDescr(ca_descr, initial);
+}
+
+RESULT eDVBDemux::setCaPid(ca_pid_t *ca_pid)
+{
+	return decsa->SetCaPid(ca_pid);
+}
+
+bool eDVBDemux::decrypt(uint8_t *data, int len, int &packetsCount) {
+	return decsa->Decrypt(data, len, packetsCount);
+}
+
 void eDVBSectionReader::data(int)
 {
 	uint8_t data[4096]; // max. section size
diff -Naur enigma2-PLi/lib/dvb/demux.h enigma2-PersianPrince/lib/dvb/demux.h
--- enigma2-PLi/lib/dvb/demux.h	2018-10-26 16:05:52.000000000 +0330
+++ enigma2-PersianPrince/lib/dvb/demux.h	2018-10-27 11:38:48.483975114 +0330
@@ -4,6 +4,7 @@
 #include <aio.h>
 #include <lib/dvb/idvb.h>
 #include <lib/dvb/idemux.h>
+#include <lib/dvb/decsa.h>
 #include <lib/dvb/pvrparse.h>
 #include "filepush.h"
 
@@ -34,9 +35,12 @@
 	int openDVR(int flags);
 
 	int getRefCount() { return ref; }
+	RESULT setCaDescr(ca_descr_t *ca_descr, bool initial);
+	RESULT setCaPid(ca_pid_t *ca_pid);
+	bool decrypt(uint8_t *data, int len, int &packetsCount);
 private:
 	int adapter, demux, source;
-
+	cDeCSA *decsa;
 	int m_dvr_busy;
 	int m_dvr_id;
 	int m_dvr_source_offset;
diff -Naur enigma2-PLi/lib/dvb/dvb.cpp enigma2-PersianPrince/lib/dvb/dvb.cpp
--- enigma2-PLi/lib/dvb/dvb.cpp	2018-10-26 16:05:52.000000000 +0330
+++ enigma2-PersianPrince/lib/dvb/dvb.cpp	2018-10-27 11:32:04.879867743 +0330
@@ -1479,6 +1479,21 @@
 	return false;
 }
 
+RESULT eDVBResourceManager::getAdapterDemux(ePtr<eDVBDemux> &demux, int adapter_nr, int demux_nr)
+{
+	eSmartPtrList<iDVBAdapter>::iterator i(m_adapter.begin());
+
+	while (adapter_nr && (i != m_adapter.end())) {
+		--adapter_nr;
+		++i;
+	}
+
+	if (i != m_adapter.end())
+		return i->getDemux(demux, demux_nr);
+	else
+		return -1;
+}
+
 class eDVBChannelFilePush: public eFilePushThread
 {
 public:
diff -Naur enigma2-PLi/lib/dvb/dvb.h enigma2-PersianPrince/lib/dvb/dvb.h
--- enigma2-PLi/lib/dvb/dvb.h	2018-10-26 16:05:52.000000000 +0330
+++ enigma2-PersianPrince/lib/dvb/dvb.h	2018-10-27 11:32:28.603375117 +0330
@@ -243,6 +243,7 @@
 	bool frontendIsMultistream(int index);
 	std::string getFrontendCapabilities(int index);
 	void setFrontendType(int index, const char *type);
+	RESULT getAdapterDemux(ePtr<eDVBDemux> &demux, int adapter_nr, int demux_nr);
 };
 SWIG_TEMPLATE_TYPEDEF(ePtr<eDVBResourceManager>, eDVBResourceManager);
 SWIG_EXTEND(ePtr<eDVBResourceManager>,
diff -Naur enigma2-pli/lib/dvb/ca_connector.cpp enigma2-libdvb/lib/dvb/ca_connector.cpp
--- enigma2-pli/lib/dvb/ca_connector.cpp	1970-01-01 00:00:00.000000000 +0000
+++ enigma2-libdvb/lib/dvb/ca_connector.cpp	2018-10-26 18:21:04.541942633 +0000
@@ -0,0 +1,123 @@
+#include <lib/dvb/ca_connector.h>
+#include <lib/dvb/dvb.h>
+#include <lib/actions/action.h>
+#include <lib/base/init.h>
+#include <lib/base/init_num.h>
+
+caConnector *caConnector::instance;
+
+DEFINE_REF(caConnector)
+
+caConnector::caConnector()
+{
+	int family;
+	struct nl_msg *msg;
+	
+	sock = nl_socket_alloc();
+	genl_connect(sock);
+
+	family = genl_ctrl_resolve(sock, "CA_SEND");
+	if (family<0) {
+		eDebug("Cannot resolve family name of generic netlink socket");
+		return;
+	}
+
+	ca_policy[ATTR_CA_SIZE].type = NLA_U32;
+	ca_policy[ATTR_CA_NUM].type = NLA_U16;
+	ca_policy[ATTR_CA_DESCR].type = NLA_UNSPEC;
+	ca_policy[ATTR_CA_PID].type = NLA_UNSPEC;
+
+	ASSERT(instance == 0);
+	instance = this;
+
+	msg = nlmsg_alloc();
+	genlmsg_put(msg, NL_AUTO_PID, NL_AUTO_SEQ, family, 0, NLM_F_ECHO,
+			CMD_ASK_CA_SIZE, 1);
+	nl_send_auto_complete(sock, msg);
+	nl_socket_modify_cb(sock, NL_CB_VALID, NL_CB_CUSTOM, parse_cb, NULL);
+	nl_recvmsgs_default(sock);
+	nlmsg_free(msg);
+	nl_socket_modify_cb(sock, NL_CB_VALID, NL_CB_CUSTOM, parse_cb, NULL);
+	nl_socket_disable_seq_check(sock);
+
+	run();
+}
+
+caConnector::~caConnector()
+{
+	instance = 0;
+	abort_badly();
+	kill();
+
+	nl_close(sock);
+	nl_socket_free(sock);
+}
+
+void caConnector::thread()
+{
+	hasStarted();
+
+	while (1) {
+		nl_recvmsgs_default(sock);
+	}
+}
+
+int caConnector::parse_cb(struct nl_msg *msg, void *arg) {
+	caConnector *connector = caConnector::getInstance();
+	ePtr<eDVBResourceManager> res_mgr;
+	int ret;
+
+	eDVBResourceManager::getInstance(res_mgr);
+	if (!res_mgr) {
+		eDebug("no resource manager !!!!!!!");
+		return -1;
+	}
+
+	struct nlmsghdr *nlh = nlmsg_hdr(msg);
+	struct nlattr *attrs[ATTR_MAX+1];
+
+	genlmsg_parse(nlh, 0, attrs, ATTR_MAX, connector->ca_policy);
+
+	if (attrs[ATTR_CA_SIZE]) {
+		uint32_t value = nla_get_u32(attrs[ATTR_CA_SIZE]);
+		connector->ca_size = value;
+	}
+	if (attrs[ATTR_CA_NUM] && attrs[ATTR_CA_DESCR]) {
+		unsigned short ca_num = nla_get_u16(attrs[ATTR_CA_NUM]);
+		ca_descr_t *ca = (ca_descr_t*)nla_data(attrs[ATTR_CA_DESCR]);
+		eDebug("CA_SET_DESCR ca_num %04X, idx %d, parity %d, cw %02X...%02X", ca_num, ca->index,
+				ca->parity, ca->cw[0], ca->cw[7]);
+
+		ePtr<eDVBDemux> demux;
+		ret = res_mgr->getAdapterDemux(demux, (ca_num>>8)&0xFF, ca_num&0xFF);
+		if (ret) {
+			eDebug("caConnector: DEMUX NOT FOUND !!");
+			return -1;
+		}
+
+		if(!demux->setCaDescr(ca,0)) {
+			eDebug("CA_SET_DESCR failed (%s). Expect a black screen.",strerror(errno));
+		}
+	}
+	if (attrs[ATTR_CA_NUM] && attrs[ATTR_CA_PID]) {
+		unsigned short ca_num = nla_get_u16(attrs[ATTR_CA_NUM]);
+		ca_pid_t *ca_pid = (ca_pid_t*)nla_data(attrs[ATTR_CA_PID]);
+
+		eDebug("CA_PID ca_num %04X, pid %04X, index %d", ca_num, ca_pid->pid, ca_pid->index);
+		
+		ePtr<eDVBDemux> demux;
+		ret = res_mgr->getAdapterDemux(demux, (ca_num>>8)&0xFF, ca_num&0xFF);
+		if (ret) {
+			eDebug("caConnector: DEMUX NOT FOUND !!");
+			return -1;
+		}
+
+		if(!demux->setCaPid(ca_pid)) {
+			eDebug("CA_SET_PID failed");
+		}
+	}
+
+	return 0;
+}
+
+eAutoInitPtr<caConnector> init_caConnector(eAutoInitNumbers::dvb-1, "caConnector");
diff -Naur enigma2-pli/lib/dvb/ca_connector.h enigma2-libdvb/lib/dvb/ca_connector.h
--- enigma2-pli/lib/dvb/ca_connector.h	1970-01-01 00:00:00.000000000 +0000
+++ enigma2-libdvb/lib/dvb/ca_connector.h	2018-10-26 18:17:33.056223049 +0000
@@ -0,0 +1,50 @@
+#ifndef __lib_dvb_ca_connector_h
+#define __lib_dvb_ca_connector_h
+
+#include <linux/dvb/ca.h>
+#include <lib/base/thread.h>
+#include <netlink/netlink.h>
+#include <netlink/genl/genl.h>
+#include <netlink/genl/ctrl.h>
+
+#include <lib/gdi/gmaindc.h>
+#include <lib/dvb/idvb.h>
+
+// attributes
+enum {
+	ATTR_UNSPEC,
+	ATTR_CA_SIZE,
+	ATTR_CA_NUM,
+	ATTR_CA_DESCR,
+	ATTR_CA_PID,
+        __ATTR_MAX
+};
+#define ATTR_MAX (__ATTR_MAX - 1)
+
+// commands
+enum {
+	CMD_UNSPEC,
+	CMD_ASK_CA_SIZE,
+	CMD_SET_CW,
+	CMD_SET_PID,
+	CMD_MAX
+};
+
+class caConnector: public eThread, sigc::trackable
+{
+	DECLARE_REF(caConnector);
+private:
+	int ca_size;
+	struct nla_policy ca_policy[ATTR_MAX + 1];
+	struct nl_sock *sock;
+	static caConnector *instance;
+
+	virtual void thread();
+	static int parse_cb(struct nl_msg *msg, void *arg);
+	static caConnector *getInstance() { return instance; }
+public:
+	caConnector();
+	~caConnector();
+};
+
+#endif
diff -Naur enigma2-pli/lib/dvb/decsa.cpp enigma2-libdvb/lib/dvb/decsa.cpp
--- enigma2-pli/lib/dvb/decsa.cpp	1970-01-01 00:00:00.000000000 +0000
+++ enigma2-libdvb/lib/dvb/decsa.cpp	2018-10-26 18:17:30.606156787 +0000
@@ -0,0 +1,210 @@
+/*
+ * Based on "Softcam plugin to VDR (C++)"
+ */
+
+#include <string.h>
+#include <lib/dvb/decsa.h>
+
+cDeCSA::cDeCSA(int _adapter, int _demux) {
+  adapter = _adapter;
+  demux = _demux;
+
+  cs=dvbcsa_bs_batch_size();
+  pcks = new dvbcsa_bs_batch_s[cs+1];
+
+  for (int i=0; i<=cs; i++) {
+    pcks[i].data = NULL;
+  }
+
+  memset(csa_bs_key_even,0,sizeof(csa_bs_key_even));
+  memset(csa_bs_key_odd,0,sizeof(csa_bs_key_odd));
+  memset(pidmap,0,sizeof(pidmap));
+  ResetState();
+}
+
+cDeCSA::~cDeCSA()
+{
+  for(int i=0; i<MAX_CSA_IDX; i++) {
+    if(csa_bs_key_even[i])
+      dvbcsa_bs_key_free(csa_bs_key_even[i]);
+    if(csa_bs_key_odd[i])
+      dvbcsa_bs_key_free(csa_bs_key_odd[i]);
+  }
+}
+
+void cDeCSA::ResetState(void)
+{
+  printf("adapter%d/demux%d: reset state", adapter, demux);
+  memset(even_odd,0,sizeof(even_odd));
+  memset(flags,0,sizeof(flags));
+  memset(usedPids,0,sizeof(usedPids));
+  lastData=0;
+}
+
+static bool CheckNull(const unsigned char *data, int len)
+{
+  while(--len>=0)
+    if(data[len])
+      return false;
+  return true;
+}
+
+bool cDeCSA::GetKeyStruct(int idx)
+{
+  if(!csa_bs_key_even[idx])
+    csa_bs_key_even[idx] = dvbcsa_bs_key_alloc();
+  if(!csa_bs_key_odd[idx])
+    csa_bs_key_odd[idx] = dvbcsa_bs_key_alloc();
+
+  return (csa_bs_key_even[idx]!=0 && csa_bs_key_odd[idx]!=0);
+}
+
+bool cDeCSA::SetDescr(ca_descr_t *ca_descr, bool initial)
+{
+  cMutexLock lock(&mutex);
+
+  int idx=ca_descr->index;
+  if(idx<MAX_CSA_IDX && GetKeyStruct(idx)) {
+    if(!initial && ca_descr->parity==(even_odd[idx]&0x40)>>6) {
+      if(flags[idx] & (ca_descr->parity?FL_ODD_GOOD:FL_EVEN_GOOD)) {
+        printf("adapter%d/demux%d idx %d: %s key in use (%d ms)", adapter, demux ,idx,ca_descr->parity?"odd":"even",MAX_REL_WAIT);
+        if(wait.TimedWait(mutex,MAX_REL_WAIT))
+          printf("adapter%d/demux%d idx %d: successfully waited for release", adapter, demux, idx);
+        else
+          printf("adapter%d/demux%d idx %d: timed out. setting anyways", adapter, demux, idx);
+      }
+      else
+        printf("adapter%d/demux%d idx %d: late key set...", adapter, demux, idx);
+    }
+    if(ca_descr->parity==0) {
+      dvbcsa_bs_key_set(ca_descr->cw, csa_bs_key_even[idx]);
+
+      if(!CheckNull(ca_descr->cw,8))
+        flags[idx] |= FL_EVEN_GOOD|FL_ACTIVITY;
+      else
+        printf("adapter%d/demux%d idx %d: zero even CW\n", adapter, demux, idx);
+      wait.Broadcast();
+    } else {
+      dvbcsa_bs_key_set(ca_descr->cw, csa_bs_key_odd[idx]);
+
+      if(!CheckNull(ca_descr->cw,8))
+        flags[idx] |= FL_ODD_GOOD|FL_ACTIVITY;
+      else
+        printf("adapter%d/demux%d idx%d: zero odd CW\n", adapter, demux, idx);
+      wait.Broadcast();
+    }
+  }
+
+  return true;
+}
+
+bool cDeCSA::SetCaPid(ca_pid_t *ca_pid)
+{
+  cMutexLock lock(&mutex);
+
+  if(ca_pid->index<MAX_CSA_IDX && ca_pid->pid<MAX_CSA_PIDS) {
+    int idx;
+
+    if (ca_pid->index!=-1) {
+      idx = ca_pid->index;
+      usedPids[idx]++;
+    } else {
+      idx = pidmap[ca_pid->pid];
+      usedPids[idx]--;
+      if (usedPids[idx]==0) {
+        even_odd[idx] = 0;
+        flags[idx] = 0;
+      }
+    }
+
+    pidmap[ca_pid->pid]=ca_pid->index;
+    //printf("adapter%d/demux%d idx %d: set pid %04x\n", adapter, demux, ca_pid->index, ca_pid->pid);
+    //printf("adapter%d/demux%d idx %d: udedPids %d\n", adapter, demux, idx, usedPids[idx]);
+  }
+
+  return true;
+}
+
+bool cDeCSA::Decrypt(unsigned char *data, int len, int& packetsCount)
+{
+  cMutexLock lock(&mutex);
+
+  int currIdx=-1;
+  len-=(TS_SIZE-1);
+  int l;
+  int packets=0, cryptedPackets=0;
+
+  for(l=0; l<len && cryptedPackets<cs; l+=TS_SIZE) {
+    unsigned int ev_od=data[l+3]&0xC0;
+    int adaptation_field_exist = (data[l+3]&0x30)>>4;
+
+    if((ev_od==0x80 || ev_od==0xC0) && adaptation_field_exist!=2) { // encrypted
+      int idx=pidmap[((data[l+1]<<8)+data[l+2])&(MAX_CSA_PIDS-1)];
+      if(currIdx<0 || idx==currIdx) { // same or no index
+        currIdx=idx;
+        if(ev_od!=even_odd[idx]) {
+          if (cryptedPackets==0) {
+            even_odd[idx]=ev_od;
+            wait.Broadcast();
+            printf("adapter%d/demux%d idx %d: change to %s key\n", adapter, demux, idx, (ev_od&0x40)?"odd":"even");
+
+            bool doWait=false;
+            if(ev_od&0x40) {
+              flags[idx]&=~FL_EVEN_GOOD;
+              if(!(flags[idx]&FL_ODD_GOOD)) doWait=true;
+            }
+            else {
+              flags[idx]&=~FL_ODD_GOOD;
+              if(!(flags[idx]&FL_EVEN_GOOD)) doWait=true;
+            }
+            if(doWait) {
+              printf("adapter%d/demux%d idx %d: %s key not ready (%d ms)\n",
+                  adapter, demux, idx, (ev_od&0x40)?"odd":"even", MAX_KEY_WAIT);
+              if(flags[idx]&FL_ACTIVITY) {
+                flags[idx]&=~FL_ACTIVITY;
+                if(wait.TimedWait(mutex,MAX_KEY_WAIT))
+                  printf("adapter%d/demux%d idx %d: successfully waited for key\n", adapter, demux, idx);
+                else
+                  printf("adapter%d/demux%d idx %d: timed out. proceeding anyways\n", adapter, demux, idx);
+              } else
+                printf("adapter%d/demux%d idx %d: not active. wait skipped\n", adapter, demux, idx);
+            }
+          } else {
+            break;
+          }
+        }
+      }
+      else
+        break;
+
+      if (adaptation_field_exist==1) {
+        pcks[cryptedPackets].data = data+l+4;
+        pcks[cryptedPackets].len = 184;
+      } else if (adaptation_field_exist==3) {
+        pcks[cryptedPackets].data = data+l+5+data[l+4];
+        pcks[cryptedPackets].len = 183-data[l+4];
+      }
+      data[l+3] &= 0x3F;
+      cryptedPackets++;
+    }
+    packets++;
+  }
+
+  if (cryptedPackets>0) {
+    for (int i=cryptedPackets;i<=cs;i++) {
+      pcks[i].data = NULL;
+    }
+
+    if (GetKeyStruct(currIdx)) {
+      if (even_odd[currIdx]&0x40) {
+        dvbcsa_bs_decrypt(csa_bs_key_odd[currIdx], pcks, 184);
+      } else {
+        dvbcsa_bs_decrypt(csa_bs_key_even[currIdx], pcks, 184);
+      }
+    }
+  }
+
+  packetsCount = packets;
+
+  return true;
+}
diff -Naur enigma2-pli/lib/dvb/decsa.h enigma2-libdvb/lib/dvb/decsa.h
--- enigma2-pli/lib/dvb/decsa.h	1970-01-01 00:00:00.000000000 +0000
+++ enigma2-libdvb/lib/dvb/decsa.h	2018-10-26 18:17:32.126197896 +0000
@@ -0,0 +1,47 @@
+#ifndef __dvb_decsa_h
+#define __dvb_decsa_h
+
+#include <linux/dvb/ca.h>
+#include <lib/base/condVar.h>
+
+extern "C" {
+#include <dvbcsa/dvbcsa.h>
+}
+
+#define TS_SIZE          188
+#define TS_SYNC_BYTE     0x47
+
+#define MAX_REL_WAIT 100 // time to wait if key in used on set
+#define MAX_KEY_WAIT 500 // time to wait if key not ready on change
+
+#define MAX_CSA_PIDS 8192
+#define MAX_CSA_IDX  16
+#define FL_EVEN_GOOD 1
+#define FL_ODD_GOOD  2
+#define FL_ACTIVITY  4
+
+class cDeCSA {
+private:
+  int cs;
+  unsigned char *lastData;
+  unsigned char pidmap[MAX_CSA_PIDS];
+  unsigned int even_odd[MAX_CSA_IDX], flags[MAX_CSA_IDX], usedPids[MAX_CSA_IDX];
+  cMutex mutex;
+  cCondVar wait;
+  int adapter, demux;
+  struct dvbcsa_bs_key_s* csa_bs_key_even[MAX_CSA_IDX];
+  struct dvbcsa_bs_key_s* csa_bs_key_odd[MAX_CSA_IDX];
+  struct dvbcsa_bs_batch_s *pcks;
+
+  bool GetKeyStruct(int idx);
+  void ResetState(void);
+public:
+  cDeCSA(int _adapter, int _demux);
+  ~cDeCSA();
+  bool Decrypt(unsigned char *data, int len, int& packetsCount);
+
+  bool SetDescr(ca_descr_t *ca_descr, bool initial);
+  bool SetCaPid(ca_pid_t *ca_pid);
+};
+
+#endif
diff -Naur enigma2-pli/lib/dvb/edvbdemux.h enigma2-libdvb/lib/dvb/edvbdemux.h
--- enigma2-pli/lib/dvb/edvbdemux.h	1970-01-01 00:00:00.000000000 +0000
+++ enigma2-libdvb/lib/dvb/edvbdemux.h	2018-10-26 18:17:31.666185455 +0000
@@ -0,0 +1,63 @@
+#ifndef __dvb_edvbdemux_h
+#define __dvb_edvbdemux_h
+
+#include <lib/dvb/idvb.h>
+#include <lib/dvb/idemux.h>
+#include <lib/dvb/decsa.h>
+
+class eDVBDemux: public iDVBDemux
+{
+	DECLARE_REF(eDVBDemux);
+public:
+	enum {
+		evtFlush
+	};
+	eDVBDemux(int adapter, int demux);
+	virtual ~eDVBDemux();
+
+	RESULT setSourceFrontend(int fenum);
+	int getSource() { return source; }
+	RESULT setSourcePVR(int pvrnum);
+	int getDvrId() { return m_dvr_id; }
+
+	RESULT createSectionReader(eMainloop *context, ePtr<iDVBSectionReader> &reader);
+	RESULT createPESReader(eMainloop *context, ePtr<iDVBPESReader> &reader);
+	RESULT createTSRecorder(ePtr<iDVBTSRecorder> &recorder, int packetsize = 188, bool streaming=false);
+	RESULT getMPEGDecoder(ePtr<iTSMPEGDecoder> &reader, int index);
+	RESULT getSTC(pts_t &pts, int num);
+	RESULT getCADemuxID(uint8_t &id) { id = demux; return 0; }
+	RESULT getCAAdapterID(uint8_t &id) { id = adapter; return 0; }
+	RESULT flush();
+	RESULT connectEvent(const sigc::slot1<void,int> &event, ePtr<eConnection> &conn);
+	int openDVR(int flags);
+
+	int getRefCount() { return ref; }
+
+	RESULT setCaDescr(ca_descr_t *ca_descr, bool initial);
+	RESULT setCaPid(ca_pid_t *ca_pid);
+	bool decrypt(uint8_t *data, int len, int &packetsCount);
+private:
+	int adapter, demux, source;
+	cDeCSA *decsa;
+
+	int m_dvr_busy;
+	int m_dvr_id;
+	friend class eDVBSectionReader;
+	friend class eDVBPESReader;
+	friend class eDVBAudio;
+	friend class eDVBVideo;
+	friend class eDVBPCR;
+	friend class eDVBTText;
+	friend class eDVBTSRecorder;
+	friend class eDVBCAService;
+	friend class eTSMPEGDecoder;
+#ifdef HAVE_AMLOGIC
+	int m_pvr_fd;
+	friend class eAMLTSMPEGDecoder;
+#endif
+	sigc::signal1<void, int> m_event;
+
+	int openDemux(void);
+};
+
+#endif
diff -Naur enigma2-pli/lib/dvb/Makefile.inc enigma2-libdvb/lib/dvb/Makefile.inc
--- enigma2-pli/lib/dvb/Makefile.inc	2018-10-23 22:20:52.735583284 +0000
+++ enigma2-libdvb/lib/dvb/Makefile.inc	2018-10-26 16:53:31.517584868 +0000
@@ -1,11 +1,13 @@
 noinst_LIBRARIES += dvb/libenigma_dvb.a
 
 dvb_libenigma_dvb_a_SOURCES = \
+	dvb/ca_connector.cpp \
 	dvb/cablescan.cpp \
 	dvb/cahandler.cpp \
 	dvb/crc32.cpp \
 	dvb/db.cpp \
 	dvb/decoder.cpp \
+	dvb/decsa.cpp \
 	dvb/demux.cpp \
 	dvb/dvb.cpp \
 	dvb/dvbtime.cpp \
@@ -41,14 +43,17 @@
 dvbincludedir = $(pkgincludedir)/lib/dvb
 dvbinclude_HEADERS = \
 	dvb/absdiff.h \
+	dvb/ca_connector.h \
 	dvb/cablescan.h \
 	dvb/cahandler.h \
 	dvb/crc32.h \
 	dvb/db.h \
 	dvb/decoder.h \
+	dvb/decsa.h \
 	dvb/demux.h \
 	dvb/dvb.h \
 	dvb/dvbtime.h \
+	dvb/edvbdemux.h \
 	dvb/eit.h \
 	dvb/epgcache.h \
 	dvb/esection.h \
