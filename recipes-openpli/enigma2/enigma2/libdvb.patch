diff -Naur enigma2-pli/lib/dvb/ca_connector.cpp enigma2-libdvb/lib/dvb/ca_connector.cpp
--- enigma2-pli/lib/dvb/ca_connector.cpp	1970-01-01 00:00:00.000000000 +0000
+++ enigma2-libdvb/lib/dvb/ca_connector.cpp	2018-10-27 13:56:21.749316293 +0000
@@ -0,0 +1,123 @@
+#include <lib/dvb/ca_connector.h>
+#include <lib/dvb/dvb.h>
+#include <lib/actions/action.h>
+#include <lib/base/init.h>
+#include <lib/base/init_num.h>
+
+caConnector *caConnector::instance;
+
+DEFINE_REF(caConnector)
+
+caConnector::caConnector()
+{
+	int family;
+	struct nl_msg *msg;
+	
+	sock = nl_socket_alloc();
+	genl_connect(sock);
+
+	family = genl_ctrl_resolve(sock, "CA_SEND");
+	if (family<0) {
+		eDebug("Cannot resolve family name of generic netlink socket");
+		return;
+	}
+
+	ca_policy[ATTR_CA_SIZE].type = NLA_U32;
+	ca_policy[ATTR_CA_NUM].type = NLA_U16;
+	ca_policy[ATTR_CA_DESCR].type = NLA_UNSPEC;
+	ca_policy[ATTR_CA_PID].type = NLA_UNSPEC;
+
+	ASSERT(instance == 0);
+	instance = this;
+
+	msg = nlmsg_alloc();
+	genlmsg_put(msg, NL_AUTO_PID, NL_AUTO_SEQ, family, 0, NLM_F_ECHO,
+			CMD_ASK_CA_SIZE, 1);
+	nl_send_auto_complete(sock, msg);
+	nl_socket_modify_cb(sock, NL_CB_VALID, NL_CB_CUSTOM, parse_cb, NULL);
+	nl_recvmsgs_default(sock);
+	nlmsg_free(msg);
+	nl_socket_modify_cb(sock, NL_CB_VALID, NL_CB_CUSTOM, parse_cb, NULL);
+	nl_socket_disable_seq_check(sock);
+
+	run();
+}
+
+caConnector::~caConnector()
+{
+	instance = 0;
+	abort_badly();
+	kill();
+
+	nl_close(sock);
+	nl_socket_free(sock);
+}
+
+void caConnector::thread()
+{
+	hasStarted();
+
+	while (1) {
+		nl_recvmsgs_default(sock);
+	}
+}
+
+int caConnector::parse_cb(struct nl_msg *msg, void *arg) {
+	caConnector *connector = caConnector::getInstance();
+	ePtr<eDVBResourceManager> res_mgr;
+	int ret;
+
+	eDVBResourceManager::getInstance(res_mgr);
+	if (!res_mgr) {
+		eDebug("no resource manager !!!!!!!");
+		return -1;
+	}
+
+	struct nlmsghdr *nlh = nlmsg_hdr(msg);
+	struct nlattr *attrs[ATTR_MAX+1];
+
+	genlmsg_parse(nlh, 0, attrs, ATTR_MAX, connector->ca_policy);
+
+	if (attrs[ATTR_CA_SIZE]) {
+		uint32_t value = nla_get_u32(attrs[ATTR_CA_SIZE]);
+		connector->ca_size = value;
+	}
+	if (attrs[ATTR_CA_NUM] && attrs[ATTR_CA_DESCR]) {
+		unsigned short ca_num = nla_get_u16(attrs[ATTR_CA_NUM]);
+		ca_descr_t *ca = (ca_descr_t*)nla_data(attrs[ATTR_CA_DESCR]);
+		eDebug("CA_SET_DESCR ca_num %04X, idx %d, parity %d, cw %02X...%02X", ca_num, ca->index,
+				ca->parity, ca->cw[0], ca->cw[7]);
+
+		ePtr<eDVBDemux> demux;
+		ret = res_mgr->getAdapterDemux(demux, (ca_num>>8)&0xFF, ca_num&0xFF);
+		if (ret) {
+			eDebug("caConnector: DEMUX NOT FOUND !!");
+			return -1;
+		}
+
+		if(!demux->setCaDescr(ca,0)) {
+			eDebug("CA_SET_DESCR failed (%s). Expect a black screen.",strerror(errno));
+		}
+	}
+	if (attrs[ATTR_CA_NUM] && attrs[ATTR_CA_PID]) {
+		unsigned short ca_num = nla_get_u16(attrs[ATTR_CA_NUM]);
+		ca_pid_t *ca_pid = (ca_pid_t*)nla_data(attrs[ATTR_CA_PID]);
+
+		eDebug("CA_PID ca_num %04X, pid %04X, index %d", ca_num, ca_pid->pid, ca_pid->index);
+		
+		ePtr<eDVBDemux> demux;
+		ret = res_mgr->getAdapterDemux(demux, (ca_num>>8)&0xFF, ca_num&0xFF);
+		if (ret) {
+			eDebug("caConnector: DEMUX NOT FOUND !!");
+			return -1;
+		}
+
+		if(!demux->setCaPid(ca_pid)) {
+			eDebug("CA_SET_PID failed");
+		}
+	}
+
+	return 0;
+}
+
+eAutoInitPtr<caConnector> init_caConnector(eAutoInitNumbers::dvb-1, "caConnector");
diff -Naur enigma2-pli/lib/dvb/ca_connector.h enigma2-libdvb/lib/dvb/ca_connector.h
--- enigma2-pli/lib/dvb/ca_connector.h	1970-01-01 00:00:00.000000000 +0000
+++ enigma2-libdvb/lib/dvb/ca_connector.h	2018-10-27 13:56:21.759316460 +0000
@@ -0,0 +1,50 @@
+#ifndef __lib_dvb_ca_connector_h
+#define __lib_dvb_ca_connector_h
+
+#include <linux/dvb/ca.h>
+#include <lib/base/thread.h>
+#include <netlink/netlink.h>
+#include <netlink/genl/genl.h>
+#include <netlink/genl/ctrl.h>
+
+#include <lib/gdi/gmaindc.h>
+#include <lib/dvb/idvb.h>
+
+// attributes
+enum {
+	ATTR_UNSPEC,
+	ATTR_CA_SIZE,
+	ATTR_CA_NUM,
+	ATTR_CA_DESCR,
+	ATTR_CA_PID,
+        __ATTR_MAX
+};
+#define ATTR_MAX (__ATTR_MAX - 1)
+
+// commands
+enum {
+	CMD_UNSPEC,
+	CMD_ASK_CA_SIZE,
+	CMD_SET_CW,
+	CMD_SET_PID,
+	CMD_MAX
+};
+
+class caConnector: public eThread, sigc::trackable
+{
+	DECLARE_REF(caConnector);
+private:
+	int ca_size;
+	struct nla_policy ca_policy[ATTR_MAX + 1];
+	struct nl_sock *sock;
+	static caConnector *instance;
+
+	virtual void thread();
+	static int parse_cb(struct nl_msg *msg, void *arg);
+	static caConnector *getInstance() { return instance; }
+public:
+	caConnector();
+	~caConnector();
+};
+
+#endif
diff -Naur enigma2-pli/lib/dvb/decoder.cpp enigma2-libdvb/lib/dvb/decoder.cpp
--- enigma2-pli/lib/dvb/decoder.cpp	2018-10-23 22:20:52.795585018 +0000
+++ enigma2-libdvb/lib/dvb/decoder.cpp	2018-11-03 07:12:15.030790928 +0000
@@ -7,6 +7,7 @@
 #include <linux/dvb/audio.h>
 #include <linux/dvb/video.h>
 #include <linux/dvb/dmx.h>
+/*	#include <lib/gdi/xineLib.h>	--->	#include <lib/dvb/omxdecoder.h>	*/
 
 #include <unistd.h>
 #include <fcntl.h>
@@ -52,8 +53,25 @@
 #endif
 }
 
-int eDVBAudio::startPid(int pid, int type)
+#define STREAM_SPU_BITMAP_HDMV                    0x90
+#define ISO_13818_AUDIO                           0x04
+#define STREAM_VIDEO_VC1                          0xea /* VC-1 Video */
+#define HDMV_AUDIO_80_PCM                         0x80 /* BluRay PCM */
+#define STREAM_AUDIO_AC3                          0x81
+#define HDMV_AUDIO_82_DTS                         0x82 /* DTS */
+#define HDMV_AUDIO_83_TRUEHD                      0x83 /* Dolby TrueHD, primary audio */
+#define HDMV_AUDIO_84_EAC3                        0x84 /* Dolby Digital plus, primary audio */
+#define HDMV_AUDIO_85_DTS_HRA                     0x85 /* DTS-HRA */
+#define HDMV_AUDIO_86_DTS_HD_MA                   0x86 /* DTS-HD Master audio */
+#define ISO_IEC_13818_7_ADTS_AAC_MPEG2_LOWER      0x0F /* AAC Xtra TV */
+//#define ISO_IEC_13818_7_ADTS_AAC                  0x2B
+//#define ISO_IEC_13818_7_ADTS_AAC_AES_128_CBC      0xCF
+
+//int eDVBAudio::startPid(int pid, int type)
+int eDVBAudio::startPid(int pid, int type, bool mode)
 {
+/*	cXineLib *xineLib = cXineLib::getInstance();	*/
+
 	if (m_fd_demux >= 0)
 	{
 		dmx_pes_filter_params pes;
@@ -81,54 +99,67 @@
 		if (::ioctl(m_fd_demux, DMX_SET_PES_FILTER, &pes) < 0)
 		{
 			eDebugNoNewLine("failed: %m\n");
-			return -errno;
+//			return -errno;
 		}
 		eDebugNoNewLine("ok\n");
 		eDebugNoNewLineStart("[eDVBAudio%d] DEMUX_START ", m_dev);
 		if (::ioctl(m_fd_demux, DMX_START) < 0)
 		{
 			eDebugNoNewLine("failed: %m\n");
-			return -errno;
+//			return -errno;
 		}
 		eDebugNoNewLine("ok\n");
 	}
 
-	if (m_fd >= 0)
-	{
+//	if (m_fd >= 0)
+//	{
 		int bypass = 0;
-
+//		xine_type = 0;
 		switch (type)
 		{
 		case aMPEG:
 			bypass = 1;
+//			xine_type = ISO_13818_AUDIO;
 			break;
 		case aAC3:
 			bypass = 0;
+//			xine_type = STREAM_AUDIO_AC3;
 			break;
 		case aDTS:
 			bypass = 2;
+//			xine_type = HDMV_AUDIO_82_DTS;
 			break;
 		case aAAC:
 			bypass = 8;
+//			xine_type = ISO_IEC_13818_7_ADTS_AAC_MPEG2_LOWER;
 			break;
 		case aAACHE:
 			bypass = 9;
+//			xine_type = ?
 			break;
 		case aLPCM:
 			bypass = 6;
+//			xine_type = HDMV_AUDIO_80_PCM;
 			break;
 		case aDTSHD:
 			bypass = 0x10;
+//			xine_type = HDMV_AUDIO_86_DTS_HD_MA;
 			break;
 		case aDDP:
-#ifdef DREAMBOX
-		bypass = 7;
-#else
-		bypass = 0x22;
-#endif
+		#ifdef DREAMBOX
+			bypass = 7;
+		#else
+			bypass = 0x22;
+//			xine_type = HDMV_AUDIO_84_EAC3;
+		#endif
 		break;
 		}
 
+/*		xineLib->setAudioType(pid, xine_type);	*/
+		// Radio mode
+/*		if (mode)
+			xineLib->playVideo();	*/	
+
 		eDebugNoNewLineStart("[eDVBAudio%d] AUDIO_SET_BYPASS bypass=%d ", m_dev, bypass);
 		if (::ioctl(m_fd, AUDIO_SET_BYPASS_MODE, bypass) < 0)
 			eDebugNoNewLine("failed: %m\n");
@@ -140,7 +171,7 @@
 			eDebugNoNewLine("failed: %m\n");
 		else
 			eDebugNoNewLine("ok\n");
-	}
+//	}
 	return 0;
 }
 
@@ -309,11 +340,14 @@
 #define VIDEO_STREAMTYPE_H265_HEVC 7
 #define VIDEO_STREAMTYPE_AVS 16
 
-int eDVBVideo::startPid(int pid, int type)
+//int eDVBVideo::startPid(int pid, int type)
+int eDVBVideo::startPid(int pid, int type, bool is_pvr)
 {
-	if (m_fd >= 0)
+//	if (m_fd >= 0)
+//	{
+	int streamtype = VIDEO_STREAMTYPE_MPEG2;
+	if (is_pvr)
 	{
-		int streamtype = VIDEO_STREAMTYPE_MPEG2;
 		switch (type)
 		{
 		default:
@@ -341,7 +375,7 @@
 			streamtype = VIDEO_STREAMTYPE_AVS;
 			break;
 		}
-
+		type = streamtype;		
 		eDebugNoNewLineStart("[eDVBVideo%d] VIDEO_SET_STREAMTYPE %d - ", m_dev, streamtype);
 		if (::ioctl(m_fd, VIDEO_SET_STREAMTYPE, streamtype) < 0)
 			eDebugNoNewLine("failed: %m\n");
@@ -375,27 +409,30 @@
 		if (::ioctl(m_fd_demux, DMX_SET_PES_FILTER, &pes) < 0)
 		{
 			eDebugNoNewLine("failed: %m\n");
-			return -errno;
+//			return -errno;
 		}
 		eDebugNoNewLine("ok\n");
 		eDebugNoNewLineStart("[eDVBVideo%d] DEMUX_START ", m_dev);
 		if (::ioctl(m_fd_demux, DMX_START) < 0)
 		{
 			eDebugNoNewLine("failed: %m\n");
-			return -errno;
+//			return -errno;
 		}
 		eDebugNoNewLine("ok\n");
 	}
 
-	if (m_fd >= 0)
-	{
+//	if (m_fd >= 0)
+//	{
+/*		cXineLib *xineLib = cXineLib::getInstance();
+		xineLib->setVideoType(pid, type);	*/
 		freeze();  // why freeze here?!? this is a problem when only a pid change is requested... because of the unfreeze logic in Decoder::setState
 		eDebugNoNewLineStart("[eDVBVideo%d] VIDEO_PLAY ", m_dev);
 		if (::ioctl(m_fd, VIDEO_PLAY) < 0)
 			eDebugNoNewLine("failed: %m\n");
 		else
 			eDebugNoNewLine("ok\n");
-	}
+//	}
+/*	xineLib->playVideo();	*/	
 	return 0;
 }
 
@@ -404,10 +441,10 @@
 	if (m_fd_demux >= 0)
 	{
 		eDebugNoNewLineStart("[eDVBVideo%d] DEMUX_STOP  ", m_dev);
-		if (::ioctl(m_fd_demux, DMX_STOP) < 0)
-			eDebugNoNewLine("failed: %m\n");
-		else
-			eDebugNoNewLine("ok\n");
+//		if (::ioctl(m_fd_demux, DMX_STOP) < 0)
+//			eDebugNoNewLine("failed: %m\n");
+//		else
+		eDebugNoNewLine("ok\n");
 	}
 
 	if (m_fd >= 0)
@@ -418,6 +455,8 @@
 		else
 			eDebugNoNewLine("ok\n");
 	}
+/*	cXineLib *xineLib = cXineLib::getInstance();
+	xineLib->stopVideo();	*/
 }
 
 void eDVBVideo::flush()
@@ -442,6 +481,8 @@
 		else
 			eDebugNoNewLine("ok\n");
 	}
+/*	cXineLib *xineLib = cXineLib::getInstance();
+	xineLib->VideoPause();	*/	
 }
 
 void eDVBVideo::unfreeze()
@@ -454,6 +495,8 @@
 		else
 			eDebugNoNewLine("ok\n");
 	}
+/*	cXineLib *xineLib = cXineLib::getInstance();
+	xineLib->VideoResume();	*/
 }
 
 int eDVBVideo::setSlowMotion(int repeat)
@@ -488,14 +531,19 @@
 
 int eDVBVideo::getPTS(pts_t &now)
 {
-	if (m_fd >= 0)
-	{
+//	if (m_fd >= 0)
+//	{
 		int ret = ::ioctl(m_fd, VIDEO_GET_PTS, &now);
+/*		cXineLib *xineLib = cXineLib::getInstance();
+		int ret = xineLib->getPTS(now);	*/
 		if (ret < 0)
+		{
 			eDebug("[eDVBVideo%d] VIDEO_GET_PTS failed: %m", m_dev);
+			return 0;
+		}
 		return ret;
-	}
-	return 0;
+//	}
+//	return 0;
 }
 
 eDVBVideo::~eDVBVideo()
@@ -877,7 +925,8 @@
 		if ((m_apid >= 0) && (m_apid < 0x1FFF) && !noaudio)
 		{
 			m_audio = new eDVBAudio(m_demux, m_decoder);
-			if (m_audio->startPid(m_apid, m_atype))
+//			if (m_audio->startPid(m_apid, m_atype))
+			if (m_audio->startPid(m_apid, m_atype, m_is_radio))
 				res = -1;
 		}
 		m_changed &= ~changeAudio;
@@ -888,8 +937,18 @@
 		{
 			m_video = new eDVBVideo(m_demux, m_decoder);
 			m_video->connectEvent(sigc::mem_fun(*this, &eTSMPEGDecoder::video_event), m_video_event_conn);
-			if (m_video->startPid(m_vpid, m_vtype))
-				res = -1;
+//			if (m_video->startPid(m_vpid, m_vtype))
+//				res = -1;
+			if (m_vstreamtype != 0)
+			{
+				if (m_video->startPid(m_vpid, m_vstreamtype, m_is_pvr))
+					res = -1;
+			}
+			else
+			{
+				if (m_video->startPid(m_vpid, m_vtype, m_is_pvr))
+					res = -1;
+			}
 		}
 		m_changed &= ~changeVideo;
 	}
@@ -994,7 +1053,8 @@
 
 eTSMPEGDecoder::eTSMPEGDecoder(eDVBDemux *demux, int decoder)
 	: m_demux(demux),
-		m_vpid(-1), m_vtype(-1), m_apid(-1), m_atype(-1), m_pcrpid(-1), m_textpid(-1),
+//		m_vpid(-1), m_vtype(-1), m_apid(-1), m_atype(-1), m_pcrpid(-1), m_textpid(-1),
+		m_vpid(-1), m_vtype(-1), m_apid(-1), m_atype(-1), m_pcrpid(-1), m_textpid(-1), m_vstreamtype(-1), m_is_pvr(false), m_is_radio(false),
 		m_changed(0), m_decoder(decoder), m_video_clip_fd(-1), m_showSinglePicTimer(eTimer::create(eApp))
 {
 	if (m_demux)
@@ -1023,27 +1083,39 @@
 		eTuxtxtApp::getInstance()->freeCache();
 }
 
-RESULT eTSMPEGDecoder::setVideoPID(int vpid, int type)
+//RESULT eTSMPEGDecoder::setVideoPID(int vpid, int type)
+RESULT eTSMPEGDecoder::setVideoPID(int vpid, int type, int streamtype)
 {
-	if ((m_vpid != vpid) || (m_vtype != type))
+	printf("eTSMPEGDecoder setVideoPID %d\n", vpid);
+//	if ((m_vpid != vpid) || (m_vtype != type))
+	if ((m_vpid != vpid) || (m_vtype != type) || (m_vstreamtype != streamtype))
 	{
 		m_changed |= changeVideo;
 		m_vpid = vpid;
 		m_vtype = type;
+		m_vstreamtype = streamtype;
+		
+		if (m_vstreamtype == 0)
+		  m_is_pvr = true;
+		else
+		  m_is_pvr = false;		
 	}
 	return 0;
 }
 
-RESULT eTSMPEGDecoder::setAudioPID(int apid, int type)
+//RESULT eTSMPEGDecoder::setAudioPID(int apid, int type)
+RESULT eTSMPEGDecoder::setAudioPID(int apid, int type, bool amode)
 {
 	/* do not set an audio pid on decoders without audio support */
-	if (!m_has_audio) apid = -1;
+/*	if (!m_has_audio) apid = -1;	*/
 
+	printf("eTSMPEGDecoder setAudioPID %d\n", apid);
 	if ((m_apid != apid) || (m_atype != type))
 	{
 		m_changed |= changeAudio;
 		m_atype = type;
 		m_apid = apid;
+		m_is_radio = amode;
 	}
 	return 0;
 }
@@ -1107,6 +1179,7 @@
 
 RESULT eTSMPEGDecoder::play()
 {
+	printf("eTSMPEGDecoder play\n");
 	if (m_state == statePlay)
 	{
 		if (!m_changed)
@@ -1121,6 +1194,7 @@
 
 RESULT eTSMPEGDecoder::pause()
 {
+	printf("eTSMPEGDecoder pause\n");
 	if (m_state == statePause)
 		return 0;
 	m_state = statePause;
diff -Naur enigma2-pli/lib/dvb/decoder.h enigma2-libdvb/lib/dvb/decoder.h
--- enigma2-pli/lib/dvb/decoder.h	2018-10-23 22:20:52.805585307 +0000
+++ enigma2-libdvb/lib/dvb/decoder.h	2018-11-01 17:32:32.799690388 +0000
@@ -3,6 +3,7 @@
 
 #include <lib/base/object.h>
 #include <lib/dvb/demux.h>
+//#include <lib/gdi/gxlibdc.h>	--->	#include <lib/gdi/omx.h>
 
 class eSocketNotifier;
 
@@ -18,7 +19,8 @@
 	enum { aMonoLeft, aStereo, aMonoRight };
 	void setChannel(int channel);
 	void stop();
-	int startPid(int pid, int type);
+//	int startPid(int pid, int type);
+	int startPid(int pid, int type, bool mode);
 	void flush();
 	void freeze();
 	void unfreeze();
@@ -43,7 +45,8 @@
 	enum { MPEG2, MPEG4_H264, VC1 = 3, MPEG4_Part2, VC1_SM, MPEG1, H265_HEVC, AVS = 16 };
 	eDVBVideo(eDVBDemux *demux, int dev);
 	void stop();
-	int startPid(int pid, int type=MPEG2);
+//	int startPid(int pid, int type=MPEG2);
+	int startPid(int pid, int type=MPEG2, bool is_pvr=false);
 	void flush();
 	void freeze();
 	int setSlowMotion(int repeat);
@@ -99,7 +102,9 @@
 	ePtr<eDVBVideo> m_video;
 	ePtr<eDVBPCR> m_pcr;
 	ePtr<eDVBTText> m_text;
-	int m_vpid, m_vtype, m_apid, m_atype, m_pcrpid, m_textpid;
+//	int m_vpid, m_vtype, m_apid, m_atype, m_pcrpid, m_textpid;
+	int m_vpid, m_vtype, m_apid, m_atype, m_pcrpid, m_textpid, m_vstreamtype;
+	bool m_is_pvr, m_is_radio;
 	enum
 	{
 		changeVideo = 1,
@@ -126,8 +131,10 @@
 	enum { pidNone = -1 };
 	eTSMPEGDecoder(eDVBDemux *demux, int decoder);
 	virtual ~eTSMPEGDecoder();
-	RESULT setVideoPID(int vpid, int type);
-	RESULT setAudioPID(int apid, int type);
+//	RESULT setVideoPID(int vpid, int type);
+//	RESULT setAudioPID(int apid, int type);
+	RESULT setVideoPID(int vpid, int type, int streamtype);
+	RESULT setAudioPID(int apid, int type, bool amode);
 	RESULT setAudioChannel(int channel);
 	int getAudioChannel();
 	RESULT setPCMDelay(int delay);
diff -Naur enigma2-pli/lib/dvb/decsa.cpp enigma2-libdvb/lib/dvb/decsa.cpp
--- enigma2-pli/lib/dvb/decsa.cpp	1970-01-01 00:00:00.000000000 +0000
+++ enigma2-libdvb/lib/dvb/decsa.cpp	2018-10-27 13:56:21.779316795 +0000
@@ -0,0 +1,210 @@
+/*
+ * Based on "Softcam plugin to VDR (C++)"
+ */
+
+#include <string.h>
+#include <lib/dvb/decsa.h>
+
+cDeCSA::cDeCSA(int _adapter, int _demux) {
+  adapter = _adapter;
+  demux = _demux;
+
+  cs=dvbcsa_bs_batch_size();
+  pcks = new dvbcsa_bs_batch_s[cs+1];
+
+  for (int i=0; i<=cs; i++) {
+    pcks[i].data = NULL;
+  }
+
+  memset(csa_bs_key_even,0,sizeof(csa_bs_key_even));
+  memset(csa_bs_key_odd,0,sizeof(csa_bs_key_odd));
+  memset(pidmap,0,sizeof(pidmap));
+  ResetState();
+}
+
+cDeCSA::~cDeCSA()
+{
+  for(int i=0; i<MAX_CSA_IDX; i++) {
+    if(csa_bs_key_even[i])
+      dvbcsa_bs_key_free(csa_bs_key_even[i]);
+    if(csa_bs_key_odd[i])
+      dvbcsa_bs_key_free(csa_bs_key_odd[i]);
+  }
+}
+
+void cDeCSA::ResetState(void)
+{
+  printf("adapter%d/demux%d: reset state", adapter, demux);
+  memset(even_odd,0,sizeof(even_odd));
+  memset(flags,0,sizeof(flags));
+  memset(usedPids,0,sizeof(usedPids));
+  lastData=0;
+}
+
+static bool CheckNull(const unsigned char *data, int len)
+{
+  while(--len>=0)
+    if(data[len])
+      return false;
+  return true;
+}
+
+bool cDeCSA::GetKeyStruct(int idx)
+{
+  if(!csa_bs_key_even[idx])
+    csa_bs_key_even[idx] = dvbcsa_bs_key_alloc();
+  if(!csa_bs_key_odd[idx])
+    csa_bs_key_odd[idx] = dvbcsa_bs_key_alloc();
+
+  return (csa_bs_key_even[idx]!=0 && csa_bs_key_odd[idx]!=0);
+}
+
+bool cDeCSA::SetDescr(ca_descr_t *ca_descr, bool initial)
+{
+  cMutexLock lock(&mutex);
+
+  int idx=ca_descr->index;
+  if(idx<MAX_CSA_IDX && GetKeyStruct(idx)) {
+    if(!initial && ca_descr->parity==(even_odd[idx]&0x40)>>6) {
+      if(flags[idx] & (ca_descr->parity?FL_ODD_GOOD:FL_EVEN_GOOD)) {
+        printf("adapter%d/demux%d idx %d: %s key in use (%d ms)", adapter, demux ,idx,ca_descr->parity?"odd":"even",MAX_REL_WAIT);
+        if(wait.TimedWait(mutex,MAX_REL_WAIT))
+          printf("adapter%d/demux%d idx %d: successfully waited for release", adapter, demux, idx);
+        else
+          printf("adapter%d/demux%d idx %d: timed out. setting anyways", adapter, demux, idx);
+      }
+      else
+        printf("adapter%d/demux%d idx %d: late key set...", adapter, demux, idx);
+    }
+    if(ca_descr->parity==0) {
+      dvbcsa_bs_key_set(ca_descr->cw, csa_bs_key_even[idx]);
+
+      if(!CheckNull(ca_descr->cw,8))
+        flags[idx] |= FL_EVEN_GOOD|FL_ACTIVITY;
+      else
+        printf("adapter%d/demux%d idx %d: zero even CW\n", adapter, demux, idx);
+      wait.Broadcast();
+    } else {
+      dvbcsa_bs_key_set(ca_descr->cw, csa_bs_key_odd[idx]);
+
+      if(!CheckNull(ca_descr->cw,8))
+        flags[idx] |= FL_ODD_GOOD|FL_ACTIVITY;
+      else
+        printf("adapter%d/demux%d idx%d: zero odd CW\n", adapter, demux, idx);
+      wait.Broadcast();
+    }
+  }
+
+  return true;
+}
+
+bool cDeCSA::SetCaPid(ca_pid_t *ca_pid)
+{
+  cMutexLock lock(&mutex);
+
+  if(ca_pid->index<MAX_CSA_IDX && ca_pid->pid<MAX_CSA_PIDS) {
+    int idx;
+
+    if (ca_pid->index!=-1) {
+      idx = ca_pid->index;
+      usedPids[idx]++;
+    } else {
+      idx = pidmap[ca_pid->pid];
+      usedPids[idx]--;
+      if (usedPids[idx]==0) {
+        even_odd[idx] = 0;
+        flags[idx] = 0;
+      }
+    }
+
+    pidmap[ca_pid->pid]=ca_pid->index;
+    //printf("adapter%d/demux%d idx %d: set pid %04x\n", adapter, demux, ca_pid->index, ca_pid->pid);
+    //printf("adapter%d/demux%d idx %d: udedPids %d\n", adapter, demux, idx, usedPids[idx]);
+  }
+
+  return true;
+}
+
+bool cDeCSA::Decrypt(unsigned char *data, int len, int& packetsCount)
+{
+  cMutexLock lock(&mutex);
+
+  int currIdx=-1;
+  len-=(TS_SIZE-1);
+  int l;
+  int packets=0, cryptedPackets=0;
+
+  for(l=0; l<len && cryptedPackets<cs; l+=TS_SIZE) {
+    unsigned int ev_od=data[l+3]&0xC0;
+    int adaptation_field_exist = (data[l+3]&0x30)>>4;
+
+    if((ev_od==0x80 || ev_od==0xC0) && adaptation_field_exist!=2) { // encrypted
+      int idx=pidmap[((data[l+1]<<8)+data[l+2])&(MAX_CSA_PIDS-1)];
+      if(currIdx<0 || idx==currIdx) { // same or no index
+        currIdx=idx;
+        if(ev_od!=even_odd[idx]) {
+          if (cryptedPackets==0) {
+            even_odd[idx]=ev_od;
+            wait.Broadcast();
+            printf("adapter%d/demux%d idx %d: change to %s key\n", adapter, demux, idx, (ev_od&0x40)?"odd":"even");
+
+            bool doWait=false;
+            if(ev_od&0x40) {
+              flags[idx]&=~FL_EVEN_GOOD;
+              if(!(flags[idx]&FL_ODD_GOOD)) doWait=true;
+            }
+            else {
+              flags[idx]&=~FL_ODD_GOOD;
+              if(!(flags[idx]&FL_EVEN_GOOD)) doWait=true;
+            }
+            if(doWait) {
+              printf("adapter%d/demux%d idx %d: %s key not ready (%d ms)\n",
+                  adapter, demux, idx, (ev_od&0x40)?"odd":"even", MAX_KEY_WAIT);
+              if(flags[idx]&FL_ACTIVITY) {
+                flags[idx]&=~FL_ACTIVITY;
+                if(wait.TimedWait(mutex,MAX_KEY_WAIT))
+                  printf("adapter%d/demux%d idx %d: successfully waited for key\n", adapter, demux, idx);
+                else
+                  printf("adapter%d/demux%d idx %d: timed out. proceeding anyways\n", adapter, demux, idx);
+              } else
+                printf("adapter%d/demux%d idx %d: not active. wait skipped\n", adapter, demux, idx);
+            }
+          } else {
+            break;
+          }
+        }
+      }
+      else
+        break;
+
+      if (adaptation_field_exist==1) {
+        pcks[cryptedPackets].data = data+l+4;
+        pcks[cryptedPackets].len = 184;
+      } else if (adaptation_field_exist==3) {
+        pcks[cryptedPackets].data = data+l+5+data[l+4];
+        pcks[cryptedPackets].len = 183-data[l+4];
+      }
+      data[l+3] &= 0x3F;
+      cryptedPackets++;
+    }
+    packets++;
+  }
+
+  if (cryptedPackets>0) {
+    for (int i=cryptedPackets;i<=cs;i++) {
+      pcks[i].data = NULL;
+    }
+
+    if (GetKeyStruct(currIdx)) {
+      if (even_odd[currIdx]&0x40) {
+        dvbcsa_bs_decrypt(csa_bs_key_odd[currIdx], pcks, 184);
+      } else {
+        dvbcsa_bs_decrypt(csa_bs_key_even[currIdx], pcks, 184);
+      }
+    }
+  }
+
+  packetsCount = packets;
+
+  return true;
+}
diff -Naur enigma2-pli/lib/dvb/decsa.h enigma2-libdvb/lib/dvb/decsa.h
--- enigma2-pli/lib/dvb/decsa.h	1970-01-01 00:00:00.000000000 +0000
+++ enigma2-libdvb/lib/dvb/decsa.h	2018-10-27 14:31:57.420006334 +0000
@@ -0,0 +1,47 @@
+#ifndef __dvb_decsa_h
+#define __dvb_decsa_h
+
+#include <linux/dvb/ca.h>	// to be checked compatibility with dvbsoftwareca -> ca.h  
+#include <lib/base/condVar.h>
+
+extern "C" {
+#include <dvbcsa/dvbcsa.h>
+}
+
+#define TS_SIZE          188
+#define TS_SYNC_BYTE     0x47
+
+#define MAX_REL_WAIT 100 // time to wait if key in used on set
+#define MAX_KEY_WAIT 500 // time to wait if key not ready on change
+
+#define MAX_CSA_PIDS 8192
+#define MAX_CSA_IDX  16
+#define FL_EVEN_GOOD 1
+#define FL_ODD_GOOD  2
+#define FL_ACTIVITY  4
+
+class cDeCSA {
+private:
+  int cs;
+  unsigned char *lastData;
+  unsigned char pidmap[MAX_CSA_PIDS];
+  unsigned int even_odd[MAX_CSA_IDX], flags[MAX_CSA_IDX], usedPids[MAX_CSA_IDX];
+  cMutex mutex;
+  cCondVar wait;
+  int adapter, demux;
+  struct dvbcsa_bs_key_s* csa_bs_key_even[MAX_CSA_IDX];
+  struct dvbcsa_bs_key_s* csa_bs_key_odd[MAX_CSA_IDX];
+  struct dvbcsa_bs_batch_s *pcks;
+
+  bool GetKeyStruct(int idx);
+  void ResetState(void);
+public:
+  cDeCSA(int _adapter, int _demux);
+  ~cDeCSA();
+  bool Decrypt(unsigned char *data, int len, int& packetsCount);
+
+  bool SetDescr(ca_descr_t *ca_descr, bool initial);
+  bool SetCaPid(ca_pid_t *ca_pid);
+};
+
+#endif
diff -Naur enigma2-pli/lib/dvb/demux.cpp enigma2-libdvb/lib/dvb/demux.cpp
--- enigma2-pli/lib/dvb/demux.cpp	2018-10-23 22:20:52.815585596 +0000
+++ enigma2-libdvb/lib/dvb/demux.cpp	2018-10-29 20:45:33.821917217 +0000
@@ -49,7 +49,11 @@
 	}
 	unsigned int megabytes = si.totalram >> 20;
 	int result;
-	if (megabytes > 400)
+	if (megabytes > 1600)
+		result = 160; // 4096MB systems: Use 32MB IO buffers (PC)
+	else if (megabytes > 800)
+		result = 80; // 2048MB systems: Use 16MB IO buffers (PC,rpi)
+	else if (megabytes > 400)
 		result = 40; // 1024MB systems: Use 8MB IO buffers (vusolo2, vuduo2, ...)
 	else if (megabytes > 200)
 		result = 20; // 512MB systems: Use 4MB IO buffers (et9x00, vuultimo, ...)
@@ -75,11 +79,13 @@
 {
 	if (CFile::parseInt(&m_dvr_source_offset, "/proc/stb/frontend/dvr_source_offset") == 0)
 		eDebug("[eDVBDemux] using %d for PVR DMX_SET_SOURCE", m_dvr_source_offset);
-
+	decsa = new cDeCSA(adapter, demux);
+	eDebug("[RPi eDVBDemux] new cDeCSA (adapter%d, demux%d)", adapter, demux);
 }
 
 eDVBDemux::~eDVBDemux()
 {
+	delete decsa;
 }
 
 int eDVBDemux::openDemux(void)
@@ -209,6 +215,20 @@
 	return 0;
 }
 
+RESULT eDVBDemux::setCaDescr(ca_descr_t *ca_descr, bool initial)
+{
+	return decsa->SetDescr(ca_descr, initial);
+}
+
+RESULT eDVBDemux::setCaPid(ca_pid_t *ca_pid)
+{
+	return decsa->SetCaPid(ca_pid);
+}
+
+bool eDVBDemux::decrypt(uint8_t *data, int len, int &packetsCount) {
+	return decsa->Decrypt(data, len, packetsCount);
+}
+
 void eDVBSectionReader::data(int)
 {
 	uint8_t data[4096]; // max. section size
@@ -727,6 +747,7 @@
 
 RESULT eDVBTSRecorder::start()
 {
+	eDebug("eDVBTSRecorder::start");
 	std::map<int,int>::iterator i(m_pids.begin());
 
 	if (m_running)
@@ -740,6 +761,7 @@
 
 	char filename[128];
 	snprintf(filename, 128, "/dev/dvb/adapter%d/demux%d", m_demux->adapter, m_demux->demux);
+	eDebug("eDVBTSRecorder::start %s", filename);
 
 	m_source_fd = ::open(filename, O_RDONLY | O_CLOEXEC);
 
@@ -772,14 +794,16 @@
 	if (!m_target_filename.empty())
 		m_thread->startSaveMetaInformation(m_target_filename);
 
-	m_thread->start(m_source_fd);
-	m_running = 1;
+//	m_thread->start(m_source_fd);
+//	m_running = 1;
 
 	while (i != m_pids.end()) {
 		startPID(i->first);
 		++i;
 	}
 
+	m_thread->start(m_source_fd, m_demux);
+	m_running = 1;	
 	return 0;
 }
 
diff -Naur enigma2-pli/lib/dvb/demux.h enigma2-libdvb/lib/dvb/demux.h
--- enigma2-pli/lib/dvb/demux.h	2018-10-23 22:20:52.815585596 +0000
+++ enigma2-libdvb/lib/dvb/demux.h	2018-10-29 20:43:17.989257455 +0000
@@ -6,8 +6,9 @@
 #include <lib/dvb/idemux.h>
 #include <lib/dvb/pvrparse.h>
 #include "filepush.h"
+#include <lib/dvb/edvbdemux.h>
 
-class eDVBDemux: public iDVBDemux
+/*class eDVBDemux: public iDVBDemux		-->	class declaration moved to edvbdemux.h
 {
 	DECLARE_REF(eDVBDemux);
 public:
@@ -34,9 +35,12 @@
 	int openDVR(int flags);
 
 	int getRefCount() { return ref; }
+	RESULT setCaDescr(ca_descr_t *ca_descr, bool initial);
+	RESULT setCaPid(ca_pid_t *ca_pid);
+	bool decrypt(uint8_t *data, int len, int &packetsCount);
 private:
 	int adapter, demux, source;
-
+	cDeCSA *decsa;
 	int m_dvr_busy;
 	int m_dvr_id;
 	int m_dvr_source_offset;
@@ -56,7 +60,7 @@
 	sigc::signal1<void, int> m_event;
 
 	int openDemux(void);
-};
+};*/
 
 class eDVBSectionReader: public iDVBSectionReader, public sigc::trackable
 {
diff -Naur enigma2-pli/lib/dvb/dvb.cpp enigma2-libdvb/lib/dvb/dvb.cpp
--- enigma2-pli/lib/dvb/dvb.cpp	2018-10-23 22:20:52.825585885 +0000
+++ enigma2-libdvb/lib/dvb/dvb.cpp	2018-10-29 20:50:58.539310131 +0000
@@ -1479,6 +1479,21 @@
 	return false;
 }
 
+RESULT eDVBResourceManager::getAdapterDemux(ePtr<eDVBDemux> &demux, int adapter_nr, int demux_nr)
+{
+	eSmartPtrList<iDVBAdapter>::iterator i(m_adapter.begin());
+
+	while (adapter_nr && (i != m_adapter.end())) {
+		--adapter_nr;
+		++i;
+	}
+
+	if (i != m_adapter.end())
+		return i->getDemux(demux, demux_nr);
+	else
+		return -1;
+}
+
 class eDVBChannelFilePush: public eFilePushThread
 {
 public:
@@ -2096,8 +2111,9 @@
 
 RESULT eDVBChannel::getDemux(ePtr<iDVBDemux> &demux, int cap)
 {
-	ePtr<eDVBAllocatedDemux> &our_demux = (cap & capDecode) ? m_decoder_demux : m_demux;
-
+//	ePtr<eDVBAllocatedDemux> &our_demux = (cap & capDecode) ? m_decoder_demux : m_demux;
+	ePtr<eDVBAllocatedDemux> &our_demux = m_demux; /* enigma2 [RPi] */
+	
 	eDebug("[eDVBChannel] getDemux cap=%02X", cap);
 
 	if (!m_frontend)
@@ -2170,9 +2186,10 @@
 	m_source = source;
 	m_tstools.setSource(m_source, streaminfo_file);
 
+	m_pvr_fd_dst = ::open("/tmp/ENIGMA_FIFO", O_RDWR);
 	if (m_pvr_fd_dst < 0)
 	{
-		ePtr<eDVBAllocatedDemux> &demux = m_demux ? m_demux : m_decoder_demux;
+/*		ePtr<eDVBAllocatedDemux> &demux = m_demux ? m_demux : m_decoder_demux;
 		if (demux)
 		{
 			m_pvr_fd_dst = demux->get().openDVR(O_WRONLY);
@@ -2186,7 +2203,9 @@
 		{
 			eDebug("[eDVBChannel] no demux allocated yet.. so its not possible to open the dvr device!!");
 			return -ENODEV;
-		}
+		}*/
+		eDebug("can't open DVR device - FIFO file (%m)");
+		return -ENODEV;
 	}
 
 	m_pvr_thread = new eDVBChannelFilePush(m_source->getPacketSize());
@@ -2214,7 +2233,8 @@
 	}
 	if (m_pvr_fd_dst >= 0)
 	{
-		::close(m_pvr_fd_dst);
+//		::close(m_pvr_fd_dst);
+/*	Pipe '/tmp/ENIGMA_FIFO' closed in eDVBServicePlay::stop() (lib/service/servicedvb.cpp) */
 		m_pvr_fd_dst = -1;
 	}
 	m_source = NULL;
diff -Naur enigma2-pli/lib/dvb/dvb.h enigma2-libdvb/lib/dvb/dvb.h
--- enigma2-pli/lib/dvb/dvb.h	2018-10-23 22:20:52.825585885 +0000
+++ enigma2-libdvb/lib/dvb/dvb.h	2018-10-29 19:51:20.525130726 +0000
@@ -243,6 +243,7 @@
 	bool frontendIsMultistream(int index);
 	std::string getFrontendCapabilities(int index);
 	void setFrontendType(int index, const char *type);
+	RESULT getAdapterDemux(ePtr<eDVBDemux> &demux, int adapter_nr, int demux_nr);
 };
 SWIG_TEMPLATE_TYPEDEF(ePtr<eDVBResourceManager>, eDVBResourceManager);
 SWIG_EXTEND(ePtr<eDVBResourceManager>,
diff -Naur enigma2-pli/lib/dvb/edvbdemux.h enigma2-libdvb/lib/dvb/edvbdemux.h
--- enigma2-pli/lib/dvb/edvbdemux.h	1970-01-01 00:00:00.000000000 +0000
+++ enigma2-libdvb/lib/dvb/edvbdemux.h	2018-10-29 20:43:17.989257455 +0000
@@ -0,0 +1,109 @@
+#ifndef __dvb_edvbdemux_h
+#define __dvb_edvbdemux_h
+
+#include <lib/dvb/idvb.h>
+#include <lib/dvb/idemux.h>
+#include <lib/dvb/decsa.h>
+
+class eDVBDemux: public iDVBDemux
+{
+	DECLARE_REF(eDVBDemux);
+public:
+	enum {
+		evtFlush
+	};
+	eDVBDemux(int adapter, int demux);
+	virtual ~eDVBDemux();
+
+	RESULT setSourceFrontend(int fenum);
+	int getSource() { return source; }
+	RESULT setSourcePVR(int pvrnum);
+	int getDvrId() { return m_dvr_id; }
+
+	RESULT createSectionReader(eMainloop *context, ePtr<iDVBSectionReader> &reader);
+	RESULT createPESReader(eMainloop *context, ePtr<iDVBPESReader> &reader);
+	RESULT createTSRecorder(ePtr<iDVBTSRecorder> &recorder, int packetsize = 188, bool streaming=false);
+	RESULT getMPEGDecoder(ePtr<iTSMPEGDecoder> &reader, int index);
+	RESULT getSTC(pts_t &pts, int num);
+	RESULT getCADemuxID(uint8_t &id) { id = demux; return 0; }
+	RESULT getCAAdapterID(uint8_t &id) { id = adapter; return 0; }
+	RESULT flush();
+	RESULT connectEvent(const sigc::slot1<void,int> &event, ePtr<eConnection> &conn);
+	int openDVR(int flags);
+
+	int getRefCount() { return ref; }
+
+	RESULT setCaDescr(ca_descr_t *ca_descr, bool initial);
+	RESULT setCaPid(ca_pid_t *ca_pid);
+	bool decrypt(uint8_t *data, int len, int &packetsCount);
+private:
+	int adapter, demux, source;
+	cDeCSA *decsa;
+	int m_dvr_busy;
+	int m_dvr_id;
+	int m_dvr_source_offset;
+	friend class eDVBSectionReader;
+	friend class eDVBPESReader;
+	friend class eDVBAudio;
+	friend class eDVBVideo;
+	friend class eDVBPCR;
+	friend class eDVBTText;
+	friend class eDVBTSRecorder;
+	friend class eDVBCAService;
+	friend class eTSMPEGDecoder;
+#ifdef HAVE_AMLOGIC
+	int m_pvr_fd;
+	friend class eAMLTSMPEGDecoder;
+#endif
+	sigc::signal1<void, int> m_event;
+
+	int openDemux(void);
+};
+
+//	vdr/remux.h
+
+#define MAX33BIT  0x00000001FFFFFFFFLL // max. possible value with 33 bit
+
+typedef unsigned char uchar;
+
+inline bool PesLongEnough(int Length)
+{
+  return Length >= 6;
+}
+
+inline bool PesHasLength(const uchar *p)
+{
+  return p[4] | p[5];
+}
+
+inline int PesLength(const uchar *p)
+{
+  return 6 + p[4] * 256 + p[5];
+}
+
+inline int PesPayloadOffset(const uchar *p)
+{
+  return 9 + p[8];
+}
+
+inline bool PesHasPts(const uchar *p)
+{
+  return (p[7] & 0x80) && p[8] >= 5;
+}
+
+inline int64_t PesGetPts(const uchar *p)
+{
+  return ((((int64_t)p[ 9]) & 0x0E) << 29) |
+         (( (int64_t)p[10])         << 22) |
+         ((((int64_t)p[11]) & 0xFE) << 14) |
+         (( (int64_t)p[12])         <<  7) |
+         ((((int64_t)p[13]) & 0xFE) >>  1);
+}
+
+int64_t PtsDiff(int64_t Pts1, int64_t Pts2);
+       ///< Returns the difference between two PTS values. The result of Pts2 - Pts1
+       ///< is the actual number of 90kHz time ticks that pass from Pts1 to Pts2,
+       ///< properly taking into account the 33bit wrap around. If Pts2 is "before"
+       ///< Pts1, the result is negative.
+
+#endif
diff -Naur enigma2-pli/lib/dvb/filepush.cpp enigma2-libdvb/lib/dvb/filepush.cpp
--- enigma2-pli/lib/dvb/filepush.cpp	2018-10-23 22:20:52.895587908 +0000
+++ enigma2-libdvb/lib/dvb/filepush.cpp	2018-10-28 15:24:27.619417413 +0000
@@ -47,6 +47,7 @@
 {
 	ignore_but_report_signals();
 	hasStarted(); /* "start()" blocks until we get here */
+//	cXineLib *xineLib = cXineLib::getInstance();	--->	 [rpi] to be replaced with omx
 	setIoPrio(IOPRIO_CLASS_BE, 0);
 	eDebug("[eFilePushThread] START thread");
 
@@ -148,6 +149,7 @@
 				   over and over until somebody responds.
 
 				   in stream_mode, think of evtEOF as "buffer underrun occurred". */
+//			if (xineLib->end_of_stream == true)	--->	 [rpi] to be replaced with omx
 			sendEvent(evtEOF);
 
 			if (m_stream_mode)
@@ -303,9 +305,6 @@
 {
 }
 
-
-
-
 eFilePushThreadRecorder::eFilePushThreadRecorder(unsigned char* buffer, size_t buffersize):
 	m_fd_source(-1),
 	m_buffersize(buffersize),
@@ -334,7 +333,11 @@
 	/* m_stop must be evaluated after each syscall. */
 	while (!m_stop)
 	{
-		ssize_t bytes = ::read(m_fd_source, m_buffer, m_buffersize);
+		ssize_t bytes;
+		if (m_fd_source == 0)
+			bytes = m_source->read(0, m_buffer, 0);
+		else
+			bytes = ::read(m_fd_source, m_buffer, m_buffersize);
 		if (bytes < 0)
 		{
 			bytes = 0;
@@ -384,6 +387,17 @@
 	m_stop = 0;
 	run();
 }
+
+void eFilePushThreadRecorder::start(int fd, ePtr<eDVBDemux> &demux)
+{
+	eDecryptRawFile *f = new eDecryptRawFile();
+	m_source = f;
+	f->setfd(fd);
+	f->setDemux(demux);
+	m_fd_source = 0;
+	m_stop = 0;
+	run();
+}
 
 void eFilePushThreadRecorder::stop()
 {
diff -Naur enigma2-pli/lib/dvb/filepush.h enigma2-libdvb/lib/dvb/filepush.h
--- enigma2-pli/lib/dvb/filepush.h	2018-10-23 22:20:52.895587908 +0000
+++ enigma2-libdvb/lib/dvb/filepush.h	2018-10-28 15:04:29.250653398 +0000
@@ -68,6 +68,7 @@
 	void thread();
 	void stop();
 	void start(int sourcefd);
+	void start(int fd, ePtr<eDVBDemux> &demux);
 
 	enum { evtEOF, evtReadError, evtWriteError, evtUser, evtStopped };
 	sigc::signal1<void,int> m_event;
@@ -89,6 +90,7 @@
 private:
 	int m_stop;
 	eFixedMessagePump<int> m_messagepump;
+	ePtr<iTsSource> m_source;
 	void recvEvent(const int &evt);
 };
 
diff -Naur enigma2-pli/lib/dvb/frontend.cpp enigma2-libdvb/lib/dvb/frontend.cpp
--- enigma2-pli/lib/dvb/frontend.cpp	2018-10-23 22:20:52.915588486 +0000
+++ enigma2-libdvb/lib/dvb/frontend.cpp	2018-10-27 15:12:44.431555577 +0000
@@ -549,6 +549,7 @@
 	,m_state(stateClosed), m_timeout(0), m_tuneTimer(0)
 {
 	m_filename = devicenodename;
+	sscanf(devicenodename, "/dev/dvb/adapter%d", &m_dvbid);
 
 	m_timeout = eTimer::create(eApp);
 	CONNECT(m_timeout->timeout, eDVBFrontend::timeout);
@@ -2577,7 +2578,7 @@
 	}
 	if (m_simulate)
 		return 0;
-	::ioctl(m_fd, FE_ENABLE_HIGH_LNB_VOLTAGE, increased);
+//	::ioctl(m_fd, FE_ENABLE_HIGH_LNB_VOLTAGE, increased);
 	return ::ioctl(m_fd, FE_SET_VOLTAGE, vlt);
 }
 
diff -Naur enigma2-pli/lib/dvb/idvb.h enigma2-libdvb/lib/dvb/idvb.h
--- enigma2-pli/lib/dvb/idvb.h	2018-10-23 22:20:52.925588775 +0000
+++ enigma2-libdvb/lib/dvb/idvb.h	2018-11-01 21:48:30.254750906 +0000
@@ -699,11 +699,13 @@
 public:
 	enum { pidDisabled = -1 };
 		/** Set Displayed Video PID and type */
-	virtual RESULT setVideoPID(int vpid, int type)=0;
+//	virtual RESULT setVideoPID(int vpid, int type)=0;
+	virtual RESULT setVideoPID(int vpid, int type, int streamtype)=0;
 
 	enum { af_MPEG, af_AC3, af_DTS, af_AAC, af_DTSHD };
 		/** Set Displayed Audio PID and type */
-	virtual RESULT setAudioPID(int apid, int type)=0;
+//	virtual RESULT setAudioPID(int apid, int type)=0;
+	virtual RESULT setAudioPID(int apid, int type, bool mode)=0;
 
 	enum { ac_left, ac_stereo, ac_right };
 		/** Set Displayed Audio Channel */
diff -Naur enigma2-pli/lib/dvb/Makefile.inc enigma2-libdvb/lib/dvb/Makefile.inc
--- enigma2-pli/lib/dvb/Makefile.inc	2018-10-23 22:20:52.735583284 +0000
+++ enigma2-libdvb/lib/dvb/Makefile.inc	2018-10-27 13:56:21.809317298 +0000
@@ -1,11 +1,13 @@
 noinst_LIBRARIES += dvb/libenigma_dvb.a
 
 dvb_libenigma_dvb_a_SOURCES = \
+	dvb/ca_connector.cpp \
 	dvb/cablescan.cpp \
 	dvb/cahandler.cpp \
 	dvb/crc32.cpp \
 	dvb/db.cpp \
 	dvb/decoder.cpp \
+	dvb/decsa.cpp \
 	dvb/demux.cpp \
 	dvb/dvb.cpp \
 	dvb/dvbtime.cpp \
@@ -41,14 +43,17 @@
 dvbincludedir = $(pkgincludedir)/lib/dvb
 dvbinclude_HEADERS = \
 	dvb/absdiff.h \
+	dvb/ca_connector.h \
 	dvb/cablescan.h \
 	dvb/cahandler.h \
 	dvb/crc32.h \
 	dvb/db.h \
 	dvb/decoder.h \
+	dvb/decsa.h \
 	dvb/demux.h \
 	dvb/dvb.h \
 	dvb/dvbtime.h \
+	dvb/edvbdemux.h \
 	dvb/eit.h \
 	dvb/epgcache.h \
 	dvb/esection.h \
diff -Naur enigma2-pli/lib/dvb/pmtparse.cpp enigma2-libdvb/lib/dvb/pmtparse.cpp
--- enigma2-pli/lib/dvb/pmtparse.cpp	2018-10-23 22:20:52.995590798 +0000
+++ enigma2-libdvb/lib/dvb/pmtparse.cpp	2018-10-31 21:21:24.441554452 +0000
@@ -99,6 +99,7 @@
 				video.type = videoStream::vtMPEG2;
 				audio.type = audioStream::atMPEG;
 				audio.rdsPid = -1;
+				video.orig_streamtype= streamtype;
 
 				switch (streamtype)
 				{
diff -Naur enigma2-pli/lib/dvb/pmtparse.h enigma2-libdvb/lib/dvb/pmtparse.h
--- enigma2-pli/lib/dvb/pmtparse.h	2018-10-23 22:20:53.005591087 +0000
+++ enigma2-libdvb/lib/dvb/pmtparse.h	2018-10-31 21:19:52.238159091 +0000
@@ -26,6 +26,7 @@
 		int component_tag;
 		enum { vtMPEG2, vtMPEG4_H264, vtVC1 = 3, vtMPEG4_Part2, vtVC1_SM, vtMPEG1, vtH265_HEVC, vtCAVS = 16 };
 		int type;
+		int orig_streamtype;
 	};
 
 	struct audioStream
diff -Naur enigma2-pli/lib/dvb_ci/dvbci.cpp enigma2-libdvb/lib/dvb_ci/dvbci.cpp
--- enigma2-pli/lib/dvb_ci/dvbci.cpp	2018-10-23 22:20:53.105593977 +0000
+++ enigma2-libdvb/lib/dvb_ci/dvbci.cpp	2018-10-27 21:19:39.622287969 +0000
@@ -652,7 +652,7 @@
 									case interface_use_dvr:
 									{
 										std::stringstream source;
-										source << "DVR" << channel->getDvrId();
+//										source << "DVR" << channel->getDvrId();
 										ci_it->setSource(source.str());
 										break;
 									}
