diff -Naur enigma2-pli/lib/base/tools.cpp enigma2-rpicommon/lib/base/tools.cpp
--- enigma2-pli/lib/base/tools.cpp	1970-01-01 00:00:00.000000000 +0000
+++ enigma2-rpicommon/lib/base/tools.cpp	2018-10-24 18:18:57.044461492 +0000
@@ -0,0 +1,184 @@
+/*
+ * rpihddevice - Enigma2 rpihddevice library for Raspberry Pi
+ * Copyright (C) 2014, 2015, 2016 Thomas Reufer
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#include <limits.h>
+#include <sys/time.h>
+#include <time.h>
+#include <utime.h>
+#include <lib/base/eerror.h>
+#include <lib/base/tools.h>
+#include <algorithm>
+
+/*
+ * ffmpeg's implementation for rational numbers:
+ * https://github.com/FFmpeg/FFmpeg/blob/master/libavutil/rational.c
+ */
+
+// --- cTimeMs ---------------------------------------------------------------
+
+cTimeMs::cTimeMs(int Ms)
+{
+  if (Ms >= 0)
+     Set(Ms);
+  else
+     begin = 0;
+}
+
+uint64_t cTimeMs::Now(void)
+{
+#if _POSIX_TIMERS > 0 && defined(_POSIX_MONOTONIC_CLOCK)
+#define MIN_RESOLUTION 5 // ms
+  static bool initialized = false;
+  static bool monotonic = false;
+  struct timespec tp;
+  if (!initialized) {
+     // check if monotonic timer is available and provides enough accurate resolution:
+     if (clock_getres(CLOCK_MONOTONIC, &tp) == 0) {
+        long Resolution = tp.tv_nsec;
+        // require a minimum resolution:
+        if (tp.tv_sec == 0 && tp.tv_nsec <= MIN_RESOLUTION * 1000000) {
+           if (clock_gettime(CLOCK_MONOTONIC, &tp) == 0) {
+              eLog(3, "[cTimeMs] using monotonic clock (resolution is %ld ns)", Resolution);
+              monotonic = true;
+              }
+           else
+              eLog(1, "[cTimeMs] clock_gettime(CLOCK_MONOTONIC) failed");
+           }
+        else
+           eLog(3, "[cTimeMs] not using monotonic clock - resolution is too bad (%ld s %ld ns)", tp.tv_sec, tp.tv_nsec);
+        }
+     else
+        eLog(1, "[cTimeMs] clock_getres(CLOCK_MONOTONIC) failed");
+     initialized = true;
+     }
+  if (monotonic) {
+     if (clock_gettime(CLOCK_MONOTONIC, &tp) == 0)
+        return (uint64_t(tp.tv_sec)) * 1000 + tp.tv_nsec / 1000000;
+     eLog(1, "[cTimeMs] clock_gettime(CLOCK_MONOTONIC) failed");
+     monotonic = false;
+     // fall back to gettimeofday()
+     }
+#else
+#  warning Posix monotonic clock not available
+#endif
+  struct timeval t;
+  if (gettimeofday(&t, NULL) == 0)
+     return (uint64_t(t.tv_sec)) * 1000 + t.tv_usec / 1000;
+  return 0;
+}
+
+void cTimeMs::Set(int Ms)
+{
+  begin = Now() + Ms;
+}
+
+bool cTimeMs::TimedOut(void) const
+{
+  return Now() >= begin;
+}
+
+uint64_t cTimeMs::Elapsed(void) const
+{
+  return Now() - begin;
+}
+
+// ------------------------------------------------------------------
+
+cRational::cRational(double d) :
+	num(0), den(0)
+{
+	int exp;
+	frexp(d, &exp);					/*	call to	vdr/tools.h		*/
+
+	den = 1LL << (29 - std::max(exp - 1, 0));
+	num = floor(d * den + 0.5);		/*	call to	vdr/tools.h		*/
+
+	Reduce(INT_MAX);
+}
+
+bool cRational::Reduce(int max)
+{
+	cRational a0 = cRational(0, 1), a1 = cRational(1, 0);
+	int sign = (num < 0) ^ (den < 0);
+	if (int div = Gcd(abs(num), abs(den)))
+	{
+		num = abs(num) / div;
+		den = abs(den) / div;
+	}
+	if (num <= max && den <= max)
+	{
+		a1 = cRational(num, den);
+		den = 0;
+	}
+	while (den)
+	{
+		int x = num / den;
+		int nextDen = num - den * x;
+		cRational a2 = cRational(x * a1.num + a0.num, x * a1.den + a0.den);
+		if (a2.num > max || a2.den > max)
+		{
+			if (a1.num)
+				x = (max - a0.num) / a1.num;
+			if (a1.den)
+				x = std::min(x, (max - a0.den) / a1.den);
+			if (den * (2 * x * a1.den + a0.den) > num * a1.den)
+				a1 = cRational(x * a1.num + a0.num, x * a1.den + a0.den);
+			break;
+		}
+		a0 = a1;
+		a1 = a2;
+		num = den;
+		den = nextDen;
+	}
+	num = sign ? -a1.num : a1.num;
+	den = a1.den;
+	return den == 0;
+}
+
+/*
+ * Stein's binary GCD algorithm:
+ * https://en.wikipedia.org/wiki/Binary_GCD_algorithm
+ */
+
+int cRational::Gcd(int u, int v)
+{
+    if (u == v || v == 0)
+        return u;
+
+    if (u == 0)
+        return v;
+
+    // look for factors of 2
+    if (~u & 1) // u is even
+    {
+        if (v & 1) // v is odd
+            return Gcd(u >> 1, v);
+        else // both u and v are even
+            return Gcd(u >> 1, v >> 1) << 1;
+    }
+
+    if (~v & 1) // u is odd, v is even
+        return Gcd(u, v >> 1);
+
+    // reduce larger argument
+    if (u > v)
+        return Gcd((u - v) >> 1, v);
+
+    return Gcd((v - u) >> 1, u);
+}
diff -Naur enigma2-pli/lib/base/tools.h enigma2-rpicommon/lib/base/tools.h
--- enigma2-pli/lib/base/tools.h	1970-01-01 00:00:00.000000000 +0000
+++ enigma2-rpicommon/lib/base/tools.h	2018-10-28 00:03:03.451254168 +0000
@@ -0,0 +1,306 @@
+/*
+ * rpihddevice - Enigma2 rpihddevice library for Raspberry Pi
+ * Copyright (C) 2014, 2015, 2016 Thomas Reufer
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#ifndef TOOLS_H
+#define TOOLS_H
+
+#include <errno.h>
+#include <math.h>
+#include <poll.h>
+#include <stdarg.h>
+#include <stddef.h>
+#include <stdint.h>
+#include <stdlib.h>
+#include <string.h>
+
+//	vdr/tools.h
+
+typedef unsigned char uchar;
+
+#define SECSINDAY  86400
+
+#define KILOBYTE(n) ((n) * 1024)
+#define MEGABYTE(n) ((n) * 1024LL * 1024LL)
+
+#define MALLOC(type, size)  (type *)malloc(sizeof(type) * (size))
+
+class cString {
+private:
+  char *s;
+public:
+  cString(const char *S = NULL, bool TakePointer = false);
+  cString(const char *S, const char *To); ///< Copies S up to To (exclusive). To must be a valid pointer into S. If To is NULL, everything is copied.
+  cString(const cString &String);
+  virtual ~cString();
+  operator const void * () const { return s; } // to catch cases where operator*() should be used
+  operator const char * () const { return s; } // for use in (const char *) context
+  const char * operator*() const { return s; } // for use in (const void *) context (printf() etc.)
+  cString &operator=(const cString &String);
+  cString &operator=(const char *String);
+  cString &Truncate(int Index); ///< Truncate the string at the given Index (if Index is < 0 it is counted from the end of the string).
+  cString &CompactChars(char c); ///< Compact any sequence of characters 'c' to a single character, and strip all of them from the beginning and end of this string.
+  static cString sprintf(const char *fmt, ...) __attribute__ ((format (printf, 1, 2)));
+  static cString vsprintf(const char *fmt, va_list &ap);
+  };
+
+uchar *RgbToJpeg(uchar *Mem, int Width, int Height, int &Size, int Quality = 100);
+    ///< Converts the given Memory to a JPEG image and returns a pointer
+    ///< to the resulting image. Mem must point to a data block of exactly
+    ///< (Width * Height) triplets of RGB image data bytes. Upon return, Size
+    ///< will hold the number of bytes of the resulting JPEG data.
+    ///< Quality can be in the range 0..100 and controls the quality of the
+    ///< resulting image, where 100 is "best". The caller takes ownership of
+    ///< the result and has to delete it once it is no longer needed.
+    ///< The result may be NULL in case of an error.
+
+class cTimeMs {
+private:
+  uint64_t begin;
+public:
+  cTimeMs(int Ms = 0);
+      ///< Creates a timer with ms resolution and an initial timeout of Ms.
+      ///< If Ms is negative the timer is not initialized with the current
+      ///< time.
+  static uint64_t Now(void);
+  void Set(int Ms = 0);
+  bool TimedOut(void) const;
+  uint64_t Elapsed(void) const;
+  };
+
+class cPoller {
+private:
+  enum { MaxPollFiles = 16 };
+  pollfd pfd[MaxPollFiles];
+  int numFileHandles;
+public:
+  cPoller(int FileHandle = -1, bool Out = false);
+  bool Add(int FileHandle, bool Out);
+  bool Poll(int TimeoutMs = 0);
+  };  
+
+//	------------------------------------------------------------------------------------------------
+
+class cVideoResolution
+{
+public:
+
+	enum eResolution {
+		eDontChange = 0,
+		eFollowVideo,
+		e480,
+		e480w,
+		e576,
+		e576w,
+		e720,
+		e1080
+	};
+
+	static const char* Str(eResolution resolution) {
+		return	(resolution == eDontChange)  ? "don't change" :
+				(resolution == eFollowVideo) ? "follow video" :
+				(resolution == e480)         ? "480"          :
+				(resolution == e480w)        ? "480w"         :
+				(resolution == e576)         ? "576"          :
+				(resolution == e576w)        ? "576w"         :
+				(resolution == e720)         ? "720"          :
+				(resolution == e1080)        ? "1080"         :	"unknown";
+	}
+};
+
+class cVideoFrameRate
+{
+public:
+
+	enum eFrameRate {
+		eDontChange = 0,
+		eFollowVideo,
+		e24p,
+		e25p,
+		e30p,
+		e50i,
+		e50p,
+		e60i,
+		e60p
+	};
+
+	static const char* Str(eFrameRate frameRate) {
+		return	(frameRate == eDontChange)  ? "don't change" :
+				(frameRate == eFollowVideo) ? "follow video" :
+				(frameRate == e24p)         ? "p24"          :
+				(frameRate == e25p)         ? "p25"          :
+				(frameRate == e30p)         ? "p30"          :
+				(frameRate == e50i)         ? "i50"          :
+				(frameRate == e50p)         ? "p50"          :
+				(frameRate == e60i)         ? "i60"          :
+				(frameRate == e60p)         ? "p60"          : "unknown";
+	}
+};
+
+class cVideoFraming
+{
+public:
+
+	enum eFraming {
+		eFrame,
+		eCut,
+		eStretch
+	};
+
+	static const char* Str(eFraming framing) {
+		return  (framing == eFrame)   ? "frame"   :
+				(framing == eCut)     ? "cut"     :
+				(framing == eStretch) ? "stretch" : "unknown";
+	}
+};
+
+class cAudioCodec
+{
+public:
+
+	enum eCodec {
+		ePCM,
+		eMPG,
+		eAC3,
+		eEAC3,
+		eAAC,
+		eAAC_LATM,
+		eDTS,
+		eNumCodecs,
+		eInvalid
+	};
+
+	static const char* Str(eCodec codec) {
+		return  (codec == ePCM)      ? "PCM"      :
+				(codec == eMPG)      ? "MPEG"     :
+				(codec == eAC3)      ? "AC3"      :
+				(codec == eEAC3)     ? "E-AC3"    :
+				(codec == eAAC)      ? "AAC"      :
+				(codec == eAAC_LATM) ? "AAC-LATM" :
+				(codec == eDTS)      ? "DTS"      : "unknown";
+	}
+};
+
+class cAudioFormat
+{
+public:
+
+	enum eFormat {
+		ePassThrough,
+		eMultiChannelPCM,
+		eStereoPCM
+	};
+
+	static const char* Str(eFormat format) {
+		return  (format == ePassThrough)     ? "pass through"      :
+				(format == eMultiChannelPCM) ? "multi channel PCM" :
+				(format == eStereoPCM)       ? "stereo PCM"        : "unknown";
+	}
+};
+
+class cVideoCodec
+{
+public:
+
+	enum eCodec {
+		eMPEG2,
+		eH264,
+		eNumCodecs,
+		eInvalid
+	};
+
+	static const char* Str(eCodec codec) {
+		return  (codec == eMPEG2) ? "MPEG2" :
+				(codec == eH264)  ? "H264"  : "unknown";
+	}
+};
+
+class cRpiAudioPort
+{
+public:
+
+	enum ePort {
+		eLocal,
+		eHDMI
+	};
+
+	static const char* Str(ePort port) {
+		return 	(port == eLocal) ? "local" :
+				(port == eHDMI)  ? "HDMI"  : "unknown";
+	}
+};
+
+class cScanMode
+{
+public:
+
+	enum eMode {
+		eProgressive,
+		eTopFieldFirst,
+		eBottomFieldFirst
+	};
+
+	static const char* Str(eMode mode) {
+		return 	(mode == eProgressive)      ? "progressive"      :
+				(mode == eTopFieldFirst)    ? "interlaced (tff)" :
+				(mode == eBottomFieldFirst) ? "interlaced (bff)" : "unknown";
+	}
+
+	static const bool Interlaced(eMode mode) {
+		return mode != eProgressive;
+	}
+};
+
+class cVideoFrameFormat
+{
+public:
+
+	cVideoFrameFormat() : width(0), height(0), frameRate(0),
+		scanMode(cScanMode::eProgressive), pixelWidth(0), pixelHeight(0) { };
+
+	int width;
+	int height;
+	int frameRate;
+	cScanMode::eMode scanMode;
+	int pixelWidth;
+	int pixelHeight;
+
+	bool Interlaced(void) const {
+		return cScanMode::Interlaced(scanMode);
+	}
+};
+
+class cRational
+{
+public:
+
+	cRational(double d);
+	cRational(int _num, int _den) : num(_num), den(_den) { }
+
+	bool Reduce(int max);
+
+	int num;
+	int den;
+
+private:
+
+	cRational();
+	static int Gcd(int u, int v);
+};
+
+#endif