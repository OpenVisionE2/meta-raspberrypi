diff --git a/lib/base/Makefile.inc b/lib/base/Makefile.inc
index 60269d376..2c173ca42 100644
--- a/lib/base/Makefile.inc
+++ b/lib/base/Makefile.inc
@@ -4,6 +4,7 @@ base_libenigma_base_a_SOURCES = \
 	base/buffer.cpp \
 	base/cachedtssource.cpp \
 	base/cfile.cpp \
+	base/condVar.cpp \
 	base/connection.cpp \
 	base/console.cpp \
 	base/e2avahi.cpp \
@@ -33,6 +34,7 @@ baseinclude_HEADERS = \
 	base/buffer.h \
 	base/cachedtssource.h \
 	base/cfile.h \
+	base/condVar.h \
 	base/console.h \
 	base/e2avahi.h \
 	base/ebase.h \
diff --git a/lib/base/condVar.cpp b/lib/base/condVar.cpp
new file mode 100644
index 000000000..9dd90fa7e
--- /dev/null
+++ b/lib/base/condVar.cpp
@@ -0,0 +1,186 @@
+/*
+ * condVar.cpp: A simple thread base class
+ *
+ * Code from vdr/thread.c
+ * $Id: thread.c 3.2 2013/12/29 15:26:33 kls Exp $
+ * See the main source file 'vdr.c' for copyright information and
+ * how to reach the author.
+ *
+ */
+
+#include <lib/base/condVar.h>
+
+#if !defined(max)
+#define max(a, b)       ((a) > (b) ? (a) : (b))
+#endif
+
+static bool GetAbsTime(struct timespec *Abstime, int MillisecondsFromNow)
+{
+  struct timeval now;
+  if (gettimeofday(&now, NULL) == 0) {           // get current time
+     now.tv_sec  += MillisecondsFromNow / 1000;  // add full seconds
+     now.tv_usec += (MillisecondsFromNow % 1000) * 1000;  // add microseconds
+     if (now.tv_usec >= 1000000) {               // take care of an overflow
+        now.tv_sec++;
+        now.tv_usec -= 1000000;
+        }
+     Abstime->tv_sec = now.tv_sec;          // seconds
+     Abstime->tv_nsec = now.tv_usec * 1000; // nano seconds
+     return true;
+     }
+  return false;
+}
+
+// --- cMutex ----------------------------------------------------------------
+
+cMutex::cMutex(void)
+{
+  locked = 0;
+  pthread_mutexattr_t attr;
+  pthread_mutexattr_init(&attr);
+  pthread_mutexattr_settype(&attr, PTHREAD_MUTEX_ERRORCHECK_NP);
+  pthread_mutex_init(&mutex, &attr);
+}
+
+cMutex::~cMutex()
+{
+  pthread_mutex_destroy(&mutex);
+}
+
+void cMutex::Lock(void)
+{
+  pthread_mutex_lock(&mutex);
+  locked++;
+}
+
+void cMutex::Unlock(void)
+{
+ if (!--locked)
+    pthread_mutex_unlock(&mutex);
+}
+
+// --- cCondVar --------------------------------------------------------------
+
+cCondVar::cCondVar(void)
+{
+  pthread_cond_init(&cond, 0);
+}
+
+cCondVar::~cCondVar()
+{
+  pthread_cond_broadcast(&cond); // wake up any sleepers
+  pthread_cond_destroy(&cond);
+}
+
+void cCondVar::Wait(cMutex &Mutex)
+{
+  if (Mutex.locked) {
+     int locked = Mutex.locked;
+     Mutex.locked = 0; // have to clear the locked count here, as pthread_cond_wait
+                       // does an implicit unlock of the mutex
+     pthread_cond_wait(&cond, &Mutex.mutex);
+     Mutex.locked = locked;
+     }
+}
+
+bool cCondVar::TimedWait(cMutex &Mutex, int TimeoutMs)
+{
+  bool r = true; // true = condition signaled, false = timeout
+
+  if (Mutex.locked) {
+     struct timespec abstime;
+     if (GetAbsTime(&abstime, TimeoutMs)) {
+        int locked = Mutex.locked;
+        Mutex.locked = 0; // have to clear the locked count here, as pthread_cond_timedwait
+                          // does an implicit unlock of the mutex.
+        if (pthread_cond_timedwait(&cond, &Mutex.mutex, &abstime) == ETIMEDOUT)
+           r = false;
+        Mutex.locked = locked;
+        }
+     }
+  return r;
+}
+
+void cCondVar::Broadcast(void)
+{
+  pthread_cond_broadcast(&cond);
+}
+
+// --- cCondWait -------------------------------------------------------------
+
+cCondWait::cCondWait(void)
+{
+  signaled = false;
+  pthread_mutex_init(&mutex, NULL);
+  pthread_cond_init(&cond, NULL);
+}
+
+cCondWait::~cCondWait()
+{
+  pthread_cond_broadcast(&cond); // wake up any sleepers
+  pthread_cond_destroy(&cond);
+  pthread_mutex_destroy(&mutex);
+}
+
+void cCondWait::SleepMs(int TimeoutMs)
+{
+  cCondWait w;
+  w.Wait(max(TimeoutMs, 3)); // making sure the time is >2ms to avoid a possible busy wait
+}
+
+bool cCondWait::Wait(int TimeoutMs)
+{
+  pthread_mutex_lock(&mutex);
+  if (!signaled) {
+     if (TimeoutMs) {
+        struct timespec abstime;
+        if (GetAbsTime(&abstime, TimeoutMs)) {
+           while (!signaled) {
+                 if (pthread_cond_timedwait(&cond, &mutex, &abstime) == ETIMEDOUT)
+                    break;
+                 }
+           }
+        }
+     else
+        pthread_cond_wait(&cond, &mutex);
+     }
+  bool r = signaled;
+  signaled = false;
+  pthread_mutex_unlock(&mutex);
+  return r;
+}
+
+void cCondWait::Signal(void)
+{
+  pthread_mutex_lock(&mutex);
+  signaled = true;
+  pthread_cond_broadcast(&cond);
+  pthread_mutex_unlock(&mutex);
+}
+
+// --- cMutexLock ------------------------------------------------------------
+
+cMutexLock::cMutexLock(cMutex *Mutex)
+{
+  mutex = NULL;
+  locked = false;
+  Lock(Mutex);
+}
+
+cMutexLock::~cMutexLock()
+{
+  if (mutex && locked)
+     mutex->Unlock();
+}
+
+bool cMutexLock::Lock(cMutex *Mutex)
+{
+  if (Mutex && !mutex) {
+     mutex = Mutex;
+     Mutex->Lock();
+     locked = true;
+     return true;
+     }
+  return false;
+}
+
diff --git a/lib/base/condVar.h b/lib/base/condVar.h
new file mode 100644
index 000000000..718009d39
--- /dev/null
+++ b/lib/base/condVar.h
@@ -0,0 +1,214 @@
+/*
+ * condVar.h: A simple thread base class
+ *
+ * Code from vdr/thread.h
+ * $Id: thread.h 3.2 2015/01/14 11:39:55 kls Exp $
+ * See the main source file 'vdr.c' for copyright information and
+ * how to reach the author.
+ *
+ */
+
+#ifndef __THREAD_H
+#define __THREAD_H
+
+#include <errno.h>
+#include <pthread.h>
+#include <stdio.h>
+#include <sys/types.h>
+#include <sys/time.h>
+
+class cCondWait {
+private:
+  pthread_mutex_t mutex;
+  pthread_cond_t cond;
+  bool signaled;
+public:
+  cCondWait(void);
+  ~cCondWait();
+  static void SleepMs(int TimeoutMs);
+       ///< Creates a cCondWait object and uses it to sleep for TimeoutMs
+       ///< milliseconds, immediately giving up the calling thread's time
+       ///< slice and thus avoiding a "busy wait".
+       ///< In order to avoid a possible busy wait, TimeoutMs will be automatically
+       ///< limited to values >2.
+  bool Wait(int TimeoutMs = 0);
+       ///< Waits at most TimeoutMs milliseconds for a call to Signal(), or
+       ///< forever if TimeoutMs is 0.
+       ///< Returns true if Signal() has been called, false it the given
+       ///< timeout has expired.
+  void Signal(void);
+       ///< Signals a caller of Wait() that the condition it is waiting for is met.
+  };
+
+class cMutex;
+
+class cCondVar {
+private:
+  pthread_cond_t cond;
+public:
+  cCondVar(void);
+  ~cCondVar();
+  void Wait(cMutex &Mutex);
+  bool TimedWait(cMutex &Mutex, int TimeoutMs);
+  void Broadcast(void);
+  };
+
+class cRwLock {
+private:
+  pthread_rwlock_t rwlock;
+public:
+  cRwLock(bool PreferWriter = false);
+  ~cRwLock();
+  bool Lock(bool Write, int TimeoutMs = 0);
+  void Unlock(void);
+  };
+
+class cMutex {
+  friend class cCondVar;
+private:
+  pthread_mutex_t mutex;
+  int locked;
+public:
+  cMutex(void);
+  ~cMutex();
+  void Lock(void);
+  void Unlock(void);
+  };
+
+typedef pid_t tThreadId;
+
+class cThread {
+  friend class cThreadLock;
+private:
+  bool active;
+  bool running;
+  pthread_t childTid;
+  tThreadId childThreadId;
+  cMutex mutex;
+  char *description;
+  bool lowPriority;
+  static tThreadId mainThreadId;
+  static void *StartThread(cThread *Thread);
+protected:
+  void SetPriority(int Priority);
+  void SetIOPriority(int Priority);
+  void Lock(void) { mutex.Lock(); }
+  void Unlock(void) { mutex.Unlock(); }
+  virtual void Action(void) = 0;
+       ///< A derived cThread class must implement the code it wants to
+       ///< execute as a separate thread in this function. If this is
+       ///< a loop, it must check Running() repeatedly to see whether
+       ///< it's time to stop.
+  bool Running(void) { return running; }
+       ///< Returns false if a derived cThread object shall leave its Action()
+       ///< function.
+  void Cancel(int WaitSeconds = 0);
+       ///< Cancels the thread by first setting 'running' to false, so that
+       ///< the Action() loop can finish in an orderly fashion and then waiting
+       ///< up to WaitSeconds seconds for the thread to actually end. If the
+       ///< thread doesn't end by itself, it is killed.
+       ///< If WaitSeconds is -1, only 'running' is set to false and Cancel()
+       ///< returns immediately, without killing the thread.
+public:
+  cThread(const char *Description = NULL, bool LowPriority = false);
+       ///< Creates a new thread.
+       ///< If Description is present, a log file entry will be made when
+       ///< the thread starts and stops (see SetDescription()).
+       ///< The Start() function must be called to actually start the thread.
+       ///< LowPriority can be set to true to make this thread run at a lower
+       ///< priority.
+  virtual ~cThread();
+  void SetDescription(const char *Description, ...) __attribute__ ((format (printf, 2, 3)));
+       ///< Sets the description of this thread, which will be used when logging
+       ///< starting or stopping of the thread. Make sure any important information
+       ///< is within the first 15 characters of Description, because only these
+       ///< may be displayed in thread listings (like 'htop', for instance).
+  bool Start(void);
+       ///< Actually starts the thread.
+       ///< If the thread is already running, nothing happens.
+  bool Active(void);
+       ///< Checks whether the thread is still alive.
+  static tThreadId ThreadId(void);
+  static tThreadId IsMainThread(void) { return ThreadId() == mainThreadId; }
+  static void SetMainThreadId(void);
+  };
+
+// cMutexLock can be used to easily set a lock on mutex and make absolutely
+// sure that it will be unlocked when the block will be left. Several locks can
+// be stacked, so a function that makes many calls to another function which uses
+// cMutexLock may itself use a cMutexLock to make one longer lock instead of many
+// short ones.
+
+class cMutexLock {
+private:
+  cMutex *mutex;
+  bool locked;
+public:
+  cMutexLock(cMutex *Mutex = NULL);
+  ~cMutexLock();
+  bool Lock(cMutex *Mutex);
+  };
+
+// cThreadLock can be used to easily set a lock in a thread and make absolutely
+// sure that it will be unlocked when the block will be left. Several locks can
+// be stacked, so a function that makes many calls to another function which uses
+// cThreadLock may itself use a cThreadLock to make one longer lock instead of many
+// short ones.
+
+class cThreadLock {
+private:
+  cThread *thread;
+  bool locked;
+public:
+  cThreadLock(cThread *Thread = NULL);
+  ~cThreadLock();
+  bool Lock(cThread *Thread);
+  };
+
+#define LOCK_THREAD cThreadLock ThreadLock(this)
+
+class cIoThrottle {
+private:
+  static cMutex mutex;
+  static int count;
+  bool active;
+public:
+  cIoThrottle(void);
+  ~cIoThrottle();
+  void Activate(void);
+       ///< Activates the global I/O throttling mechanism.
+       ///< This function may be called any number of times, but only
+       ///< the first call after an inactive state will have an effect.
+  void Release(void);
+       ///< Releases the global I/O throttling mechanism.
+       ///< This function may be called any number of times, but only
+       ///< the first call after an active state will have an effect.
+  bool Active(void) { return active; }
+       ///< Returns true if this I/O throttling object is currently active.
+  static bool Engaged(void);
+       ///< Returns true if any I/O throttling object is currently active.
+  };
+
+// cPipe implements a pipe that closes all unnecessary file descriptors in
+// the child process.
+
+class cPipe {
+private:
+  pid_t pid;
+  FILE *f;
+public:
+  cPipe(void);
+  ~cPipe();
+  operator FILE* () { return f; }
+  bool Open(const char *Command, const char *Mode);
+  int Close(void);
+  };
+
+// SystemExec() implements a 'system()' call that closes all unnecessary file
+// descriptors in the child process.
+// With Detached=true, calls command in background and in a separate session,
+// with stdin connected to /dev/null.
+
+int SystemExec(const char *Command, bool Detached = false);
+
+#endif //__THREAD_H
